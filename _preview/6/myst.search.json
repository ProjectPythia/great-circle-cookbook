{"version":"1","records":[{"hierarchy":{"lvl1":"Great Circle Cookbook"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Great Circle Cookbook"},"content":"\n\n\n\n\n\n\n\n\n\nThis Project Pythia Cookbook covers the background and mathematics of working with great circles and, where available, this cookbook will demonstrate how to determine the features of a great circle with both existing open-source Python packages and through spherical trigonometry","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Motivation"},"type":"lvl2","url":"/#motivation","position":2},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Motivation"},"content":"A great circle is the largest circle that can be drawn onto a sphere (like the Earth) that is the same diameter of the sphere. Great Circle arcs connect two positions on the curved surface of a planet like Earth and are commonly used for navigation that relies on “as-the crow flies” directions like planes, ships, and satellites\n\n\n\nImage Source: \n\nWolfram MathWorld\n\nGreat circles are commonly used in navigation, satellites in remote sensing, and working with coordinates on planets, but can be difficult to find resources to fully explain how to use them.","type":"content","url":"/#motivation","position":3},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Authors"},"type":"lvl2","url":"/#authors","position":4},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Authors"},"content":"Cora Schneck","type":"content","url":"/#authors","position":5},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Contributors","lvl2":"Authors"},"type":"lvl3","url":"/#contributors","position":6},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Contributors","lvl2":"Authors"},"content":"","type":"content","url":"/#contributors","position":7},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Structure"},"type":"lvl2","url":"/#structure","position":8},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Structure"},"content":"This cookbook is broken into two main sections:\n\nFoundations and Terminology\n\nWorking with Great Circles","type":"content","url":"/#structure","position":9},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Foundations and Terminology","lvl2":"Structure"},"type":"lvl3","url":"/#foundations-and-terminology","position":10},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Foundations and Terminology","lvl2":"Structure"},"content":"“Great Circle Terminology”: Covers the important terminology for working with and understanding great circles\n\n“Coordinate Systems”: Covers important terminology and functions required to understand and converted to different types of coordinate systems like Cartesian, Spherical, Polar, and Latitude/Longitude\n\nEach section will make use of plotting to visually demonstrate concepts with matplotlib and cartopy","type":"content","url":"/#foundations-and-terminology","position":11},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl3","url":"/#working-with-great-circles","position":12},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"This is the main section of this notebook and will cover specific details about how to understand and calculate important features in great circles.","type":"content","url":"/#working-with-great-circles","position":13},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"1. Great Circle Arcs and Paths","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl4","url":"/#id-1-great-circle-arcs-and-paths","position":14},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"1. Great Circle Arcs and Paths","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"Distance between Points on a Great Circle Arc\n\nSpherical Distance to Degrees\n\nDetermine the Bearing of a Great Circle Arc\n\nGenerate a Great Circle Arc with Intermediate Points\n\nDetermine the Midpoint of a Great Circle Arc\n\nGenerate a Great Circle Path\n\nDetermine an Antipodal Point","type":"content","url":"/#id-1-great-circle-arcs-and-paths","position":15},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"2. Great Circles and a Point","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl4","url":"/#id-2-great-circles-and-a-point","position":16},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"2. Great Circles and a Point","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"Determine the distance of a point to a great circle arc (cross-track and along-track distance)\n\nDetermine if a point lies on a great circle arc and path (with and without tolerances)","type":"content","url":"/#id-2-great-circles-and-a-point","position":17},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"3. Great Circles and Parallels","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl4","url":"/#id-3-great-circles-and-parallels","position":18},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"3. Great Circles and Parallels","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"Determine the maximum latitude on a Great Circle Path\n\nDetermine the minimum latitude on a Great Great path\n\nDetermine when a great circle path crosses parallels","type":"content","url":"/#id-3-great-circles-and-parallels","position":19},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"4. Intersections of Great Circles","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl4","url":"/#id-4-intersections-of-great-circles","position":20},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"4. Intersections of Great Circles","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"Find the intersection of two great circle paths (always exists)\n\nFind the intersection of two great circle arcs (if it exists)","type":"content","url":"/#id-4-intersections-of-great-circles","position":21},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"5. Angles and Great Circles","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl4","url":"/#id-5-angles-and-great-circles","position":22},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"5. Angles and Great Circles","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"Calculate the acute and obtuse angle of two Great Circle paths\n\nCalculate the Directed Angle of two Great Circle paths based on an intersection point\n\nWorking with Spherical Triangles formed by great circle arcs","type":"content","url":"/#id-5-angles-and-great-circles","position":23},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"6. Spherical Polygons and Areas","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl4","url":"/#id-6-spherical-polygons-and-areas","position":24},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"6. Spherical Polygons and Areas","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"Determine clockwise/counterclockwise ordering of points on spherical polygon\n\nArea and Permieter of quadrilateral patch on a unit sphere\n\nDetermine if a given point is within a spherical polygon\n\nMean center of spherical polygon","type":"content","url":"/#id-6-spherical-polygons-and-areas","position":25},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Running the Notebooks"},"type":"lvl2","url":"/#running-the-notebooks","position":26},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Running the Notebooks"},"content":"You can either run the notebook using \n\nBinder or on your local machine.","type":"content","url":"/#running-the-notebooks","position":27},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-binder","position":28},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"content":"The simplest way to interact with a Jupyter Notebook is through\n\n\nBinder, which enables the execution of a\n\n\nJupyter Book in the cloud. The details of how this works are not\nimportant for now. All you need to know is how to launch a Pythia\nCookbooks chapter via Binder. Simply navigate your mouse to\nthe top right corner of the book chapter you are viewing and click\non the rocket ship icon, (see figure below), and be sure to select\n“launch Binder”. After a moment you should be presented with a\nnotebook that you can interact with. I.e. you’ll be able to execute\nand even change the example programs. You’ll see that the code cells\nhave no output at first, until you execute them by pressing\nShift+Enter. Complete details on how to interact with\na live Jupyter notebook are described in \n\nGetting Started with\nJupyter.","type":"content","url":"/#running-on-binder","position":29},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-your-own-machine","position":30},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"content":"If you are interested in running this material locally on your computer, you will need to follow this workflow:\n\nClone the https://github.com/ProjectPythia/great-circle-cookbook repository: git clone https://github.com/ProjectPythia/great-circle-cookbook.git\n\nMove into the great-circle-cookbook directorycd great-circle-cookbook\n\nCreate and activate your conda environment from the environment.yml fileconda env create -f environment.yml\nconda activate cookbook-gc\n\nMove into the notebooks directory and start up Jupyterlabcd notebooks/\njupyter lab","type":"content","url":"/#running-on-your-own-machine","position":31},{"hierarchy":{"lvl1":"Great Circle Terminology"},"type":"lvl1","url":"/notebooks/foundations/terminology","position":0},{"hierarchy":{"lvl1":"Great Circle Terminology"},"content":"\n\n","type":"content","url":"/notebooks/foundations/terminology","position":1},{"hierarchy":{"lvl1":"Great Circle Terminology"},"type":"lvl1","url":"/notebooks/foundations/terminology#great-circle-terminology","position":2},{"hierarchy":{"lvl1":"Great Circle Terminology"},"content":"\n\n\n\n","type":"content","url":"/notebooks/foundations/terminology#great-circle-terminology","position":3},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/foundations/terminology#overview","position":4},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Overview"},"content":"Great circles are powerful tools used in the navigation of ships and planes as well as in geoscience for working with remote sensing via satellites. Great circle mathematics make use of spherical geometry, where, rather than lines, shapes on a sphere are formed by the intersection of arcs along the curved surface.\n\nWhile spherical geometry played an important role historically in the fields of astronomy and navigation, its teaching has largely fallen out of favor since the 1950’s making finding comphrenshive resources difficult.\n\nThis notebook will cover the important and unique terminology used when working with Great Circles and spherical geometry.\n\nSpherical Geometry\n\nGreat Circles\n\nEllipsoids vs. Spheres\n\nGeodesy\n\nA Note on Resources\n\n","type":"content","url":"/notebooks/foundations/terminology#overview","position":5},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/foundations/terminology#prerequisites","position":6},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Prerequisites"},"content":"Time to learn: 20 minutes\n\n\n\n","type":"content","url":"/notebooks/foundations/terminology#prerequisites","position":7},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Spherical Geometry"},"type":"lvl2","url":"/notebooks/foundations/terminology#spherical-geometry","position":8},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Spherical Geometry"},"content":"","type":"content","url":"/notebooks/foundations/terminology#spherical-geometry","position":9},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Spherical Trigonometry","lvl2":"Spherical Geometry"},"type":"lvl3","url":"/notebooks/foundations/terminology#spherical-trigonometry","position":10},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Spherical Trigonometry","lvl2":"Spherical Geometry"},"content":"Spherical geometry (and one of it important branches: spherical trigonometry) provide solutions for relationshsips between the sides and angles on a sphere that are commonly used in right-angled triangles. Spheres are unique since unlike triangles, spheres have internal angles that add up to more than 180 degrees.\n\nThe sum of the angles of a spherical triangle is not equal to 180°. A sphere is a curved surface, but locally the laws of the flat (planar) Euclidean geometry are good approximations. In a small triangle on the face of the earth, the sum of the angles is only slightly more than 180 degrees\n\nWikipedia: Spherical geometry\n\n","type":"content","url":"/notebooks/foundations/terminology#spherical-trigonometry","position":11},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Law of Cosines","lvl2":"Spherical Geometry"},"type":"lvl3","url":"/notebooks/foundations/terminology#law-of-cosines","position":12},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Law of Cosines","lvl2":"Spherical Geometry"},"content":"“The cosine rule is the fundamental identity of spherical trigonometry: all other identities, including the sine rule, may be derived from the cosine rule” \n\n(Wikiepedia)\n\nThe law of cosines states that for the angles A, B, C and opposite sides a, b, c:cos(a) = cos(b)cos(c) + sin(b)sin(c)cos(A)cos(b) = cos(c)cos(a) + sin(c)sin(a)cos(B)cos(c) = cos(a)cos(b) + sin(a)sin(b)cos(C)","type":"content","url":"/notebooks/foundations/terminology#law-of-cosines","position":13},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Law of Sines","lvl2":"Spherical Geometry"},"type":"lvl3","url":"/notebooks/foundations/terminology#law-of-sines","position":14},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Law of Sines","lvl2":"Spherical Geometry"},"content":"The spherical law of sines states that for the angles A, B, and C and the opposite of the sides a, b, c:\\frac{sin(A)}{sin(a)} = \\frac{sin(B)}{sin(b)} = \\frac{sin(C)}{sin(c)}\n\n","type":"content","url":"/notebooks/foundations/terminology#law-of-sines","position":15},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Great Circles"},"type":"lvl2","url":"/notebooks/foundations/terminology#great-circles","position":16},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Great Circles"},"content":"","type":"content","url":"/notebooks/foundations/terminology#great-circles","position":17},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Great Circle Path vs. Great Circle Arc","lvl2":"Great Circles"},"type":"lvl3","url":"/notebooks/foundations/terminology#great-circle-path-vs-great-circle-arc","position":18},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Great Circle Path vs. Great Circle Arc","lvl2":"Great Circles"},"content":"A great circle is the largest circle that can be formed on the surface of a sphere. A great circle is created by the intersection of a plane that also passes through the center of the sphere.\n\nAll great circles:\n\nIntersect the center of the Earth\n\nDivide the Earth in half\n\nRepresent the shortest distance between any two points on the surface of the Earth\n\nFor example, the equator is an example of a great circle. The equator can be imagined as the path formed by a plane cutting through the center of the planet and intersecting the center.\n\nA great circle path is a closed path (-180 to 180 degrees longitude) that forms around the entire planet. A great circle path can be defined by a shorter great circle arc which can be formed by:\n\nAt least two points\n\nOne point, a bearing, and a distance\n\n","type":"content","url":"/notebooks/foundations/terminology#great-circle-path-vs-great-circle-arc","position":19},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Ellipsoids vs. Spheres"},"type":"lvl2","url":"/notebooks/foundations/terminology#ellipsoids-vs-spheres","position":20},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Ellipsoids vs. Spheres"},"content":"The earth is not round, instead it is an irregular ellipsoid known as a an oblate spheroid where the poles are slightly flatter. Spherical trigonometry uses a unit sphere, so working on Earth and without additional corrections, the measurements will contain up to 0.3% (22 km) when assuming the Earth is a perfect sphere (\n\nsee more).\n\nTo account for the errors when assuming the Earth is a sphere, there are various geodetic systems and ellipsoids to include in calculations.\n\n","type":"content","url":"/notebooks/foundations/terminology#ellipsoids-vs-spheres","position":21},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Geodesic and Python"},"type":"lvl2","url":"/notebooks/foundations/terminology#geodesic-and-python","position":22},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Geodesic and Python"},"content":"For the purpose of this notebook we will be taking advantage of two geodesic Python packages:\n\npyproj: Python interface to PROJ (catographic projections and coordinate transformations library)\n\ngeopy:  Python client for several popular geocoding web services\n\npyproj and geopy both take advantage of different types of (optional) ellipsoids:\n\nimport pyproj\nfor key in pyproj.list.get_ellps_map().keys():\n    print(f\"{key} = {pyproj.list.get_ellps_map()[key]}\")\n\nfrom geopy import distance\nfor key in distance.ELLIPSOIDS.keys():\n    print(f\"{key} = {distance.ELLIPSOIDS[key]}\")\n\n","type":"content","url":"/notebooks/foundations/terminology#geodesic-and-python","position":23},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"The standard reference ellipsoid for working with Earth is WGS-84","lvl2":"Geodesic and Python"},"type":"lvl3","url":"/notebooks/foundations/terminology#the-standard-reference-ellipsoid-for-working-with-earth-is-wgs-84","position":24},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"The standard reference ellipsoid for working with Earth is WGS-84","lvl2":"Geodesic and Python"},"content":"geopy by default makes use of WGS-84  which is a a unified global ellipsoid model that is used for GPS collected from satellites to calculate extremely preise measurements of the Earth. For the purpose of this notebook, this is the ellipsoid model we will be working with.\n\nprint(pyproj.list.get_ellps_map()[\"WGS84\"])\nprint(distance.ELLIPSOIDS[\"WGS-84\"])\n\nWGS-84 is an ellipsoid with a semi-major axis of 6378137.0 meters, an inverse flattening feature of 298.257223563, and a flattening factor of 0.0033528106647474805.\n\nLearn more!\n\n","type":"content","url":"/notebooks/foundations/terminology#the-standard-reference-ellipsoid-for-working-with-earth-is-wgs-84","position":25},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Geodesy"},"type":"lvl2","url":"/notebooks/foundations/terminology#geodesy","position":26},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Geodesy"},"content":"Geodesy is the complex science of measuring the Earth’s geometric shape.\n\nLearn more!","type":"content","url":"/notebooks/foundations/terminology#geodesy","position":27},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Geodesic","lvl2":"Geodesy"},"type":"lvl3","url":"/notebooks/foundations/terminology#geodesic","position":28},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Geodesic","lvl2":"Geodesy"},"content":"A geodesic is the shortest curved path between any two points on a surface. A “straight line” on the surface of a curved surface like a sphere form an arc\n\nIf an insect is placed on a surface and continually walks “forward”, by definition it will trace out a geodesic\n\nWikipedia - Geodesic\n\n\n\nThis is especially apparent when working with satellite data where the apparent “straight path” that a satellite will trace across the the surface of a planet.\n\n","type":"content","url":"/notebooks/foundations/terminology#geodesic","position":29},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"An Important Note on Resources"},"type":"lvl2","url":"/notebooks/foundations/terminology#an-important-note-on-resources","position":30},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"An Important Note on Resources"},"content":"Spherical geometry and resources associated with working with great circles can be difficult to find\n\nHere are a list of some for working mathematically with great circles:\n\nEd Williams “Avitation Formulary”\n\nMovable Type Scripts\n\n“Heavenly Mathematics: The Forgotten Art of Spherical Trigonometry” by Glen Van Brummelen\n\n“Spherical Trigonometry: A Comprehensive Approach” by Ira Arevalo Fajardo\n\n\n\n","type":"content","url":"/notebooks/foundations/terminology#an-important-note-on-resources","position":31},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/foundations/terminology#summary","position":32},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Summary"},"content":"A great circle is formed by a plane intersecting a sphere and the center, like the equator.\n\nGreat circles make use of spherical geometry to measure features on the curved surface of a unit sphere. However, planets like Earth are not perfect spheres and to account for the error are combined with geodesic calculations to reduce the error in final calculations.","type":"content","url":"/notebooks/foundations/terminology#summary","position":33},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/foundations/terminology#whats-next","position":34},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"What’s next?","lvl2":"Summary"},"content":"Coordinates and Great Circles","type":"content","url":"/notebooks/foundations/terminology#whats-next","position":35},{"hierarchy":{"lvl1":"Coordinate Types"},"type":"lvl1","url":"/notebooks/foundations/coordinates","position":0},{"hierarchy":{"lvl1":"Coordinate Types"},"content":"\n\n","type":"content","url":"/notebooks/foundations/coordinates","position":1},{"hierarchy":{"lvl1":"Coordinate Types"},"type":"lvl1","url":"/notebooks/foundations/coordinates#coordinate-types","position":2},{"hierarchy":{"lvl1":"Coordinate Types"},"content":"\n\n\n\n","type":"content","url":"/notebooks/foundations/coordinates#coordinate-types","position":3},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/foundations/coordinates#overview","position":4},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Overview"},"content":"Great circles use different types of coordinates when working with unit spheres and ellipsoids. This notebook will cover the different types of coordinates and how to convert between them.\n\nTypes of Coordinates\n\nConvert Coordinates to All Coordinate Types\n\nPlot Coordinates on a World Map\n\n","type":"content","url":"/notebooks/foundations/coordinates#overview","position":5},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/foundations/coordinates#prerequisites","position":6},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 20 minutes\n\n\n\n","type":"content","url":"/notebooks/foundations/coordinates#prerequisites","position":7},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/foundations/coordinates#imports","position":8},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Imports"},"content":"\n\nimport numpy as np                                     # working with degrees and radians\n\nimport matplotlib.pyplot as plt                        # plotting a graph\nfrom cartopy import crs as ccrs, feature as cfeature   # plotting a world map\n\n","type":"content","url":"/notebooks/foundations/coordinates#imports","position":9},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Types of Coordinates"},"type":"lvl2","url":"/notebooks/foundations/coordinates#types-of-coordinates","position":10},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Types of Coordinates"},"content":"\n\n","type":"content","url":"/notebooks/foundations/coordinates#types-of-coordinates","position":11},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Geodesic Coordinates","lvl2":"Types of Coordinates"},"type":"lvl3","url":"/notebooks/foundations/coordinates#geodesic-coordinates","position":12},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Geodesic Coordinates","lvl2":"Types of Coordinates"},"content":"Geodesic coordinates are latitude and longtiude and are measured from -90° South to 90° North and -180° East to 180° West measured from Greenwich.\n\n\n\n","type":"content","url":"/notebooks/foundations/coordinates#geodesic-coordinates","position":13},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Cartesian Coordinates","lvl2":"Types of Coordinates"},"type":"lvl3","url":"/notebooks/foundations/coordinates#cartesian-coordinates","position":14},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Cartesian Coordinates","lvl2":"Types of Coordinates"},"content":"Cartesian coordinates describe points in space based on perpendicular axis lines that meet at a single point of origin, where any point’s position is described based on the distance to the origin along xyz axis.\n\n\n\nImage Source: \n\nThree Dimensional Cartesian Coordinate System\n\nGeodesic to Cartesian Coordinates\n\nAssuming the Earth’s radius is 6378137 meters then:x = radius * cos(latitude) * cos(longitude)y = radius * cos(latitude) * sin(longitude)z = radius * sin(latitude)\n\ndef cartesian_coordinates(latitude=None, longitude=None):\n    earth_radius = 6378137  # meters\n    latitude = np.deg2rad(latitude)\n    longitude = np.deg2rad(longitude)\n    cart_x = earth_radius * np.cos(latitude) * np.cos(longitude)\n    cart_y = earth_radius * np.cos(latitude) * np.sin(longitude)\n    cart_z = earth_radius * np.sin(latitude)\n    return cart_x, cart_y, cart_z\n\n","type":"content","url":"/notebooks/foundations/coordinates#cartesian-coordinates","position":15},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Spherical Coordinates","lvl2":"Types of Coordinates"},"type":"lvl3","url":"/notebooks/foundations/coordinates#spherical-coordinates","position":16},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Spherical Coordinates","lvl2":"Types of Coordinates"},"content":"Spherical coordinates describe points in space based on three values: radial distance (rho, r) along the radial line between point and the origin, polar angle (theta, θ) between the radial line and the polar axis, and azimuth angle (phi, φ) which is the angle of rotation of the radial line around the polar axis. With a fixed radius, the 3-point coordinates (r, θ, φ) provide a coordinate along a sphere.\n\nRadial distance: distance from center to surface of sphere\n\nPolar angle: angle between radial line and polar axis\n\nAzimuth angle: angle around polar axis\n\n\n\nImage Source: \n\nWikipedia - Spherical Coordinate System\n\nConvert from cartesian (rectangular) coordinates spherical coordinatesρ^2 = x^2 + y^2 + z^2tan(θ) = \\frac{y}{x}φ = arccos(\\frac{x}{\\sqrt{x^2 + y^2 + z^2}})\n\nWhere, rho (ρ), theta (θ), phi (φ):ρ = \\sqrt{x^2 + y^2 + z^2}θ = arctan(\\frac{y}{x})φ = arccos(\\frac{x}{ρ})\n\ndef cartesian_to_spherical_coordinates(cart_x=None, cart_y=None, cart_z=None):\n    rho = np.sqrt(cart_x**2 + cart_y**2 + cart_z**2)\n    theta = np.arctan(cart_y/cart_x)\n    phi = np.arccos(cart_z / rho)\n    return rho, theta, phi \n\n","type":"content","url":"/notebooks/foundations/coordinates#spherical-coordinates","position":17},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Polar Coordinates","lvl2":"Types of Coordinates"},"type":"lvl3","url":"/notebooks/foundations/coordinates#polar-coordinates","position":18},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Polar Coordinates","lvl2":"Types of Coordinates"},"content":"Polar coordinates are a combination of latitude, longitude, and altitude from the center of the sphere (based on the radius).\n\nAssuming the Earth’s radius is 6378137 meters then:x = cos(latitude) * cos(longitude) * radiusy = cos(latitude) * sin(longitude) * radiusz = sin(latitude) * radius\n\ndef polar_coordinates(latitude=None, longitude=None):\n    earth_radius = 6378137  # meters\n    latitude = np.deg2rad(latitude)\n    longitude = np.deg2rad(longitude)\n    polar_x = np.cos(latitude) * np.sin(longitude) * earth_radius\n    polar_y = np.cos(latitude) * np.cos(longitude) * earth_radius\n    polar_z = np.sin(latitude) * earth_radius\n    return polar_x, polar_y, polar_z\n\n","type":"content","url":"/notebooks/foundations/coordinates#polar-coordinates","position":19},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Convert City Coordinates to All Coordinate Types"},"type":"lvl2","url":"/notebooks/foundations/coordinates#convert-city-coordinates-to-all-coordinate-types","position":20},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Convert City Coordinates to All Coordinate Types"},"content":"\n\n","type":"content","url":"/notebooks/foundations/coordinates#convert-city-coordinates-to-all-coordinate-types","position":21},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Display Coordinates of Cities","lvl2":"Convert City Coordinates to All Coordinate Types"},"type":"lvl3","url":"/notebooks/foundations/coordinates#display-coordinates-of-cities","position":22},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Display Coordinates of Cities","lvl2":"Convert City Coordinates to All Coordinate Types"},"content":"First, we will read in the latitude and longitude coordinates from locations csv:\n\nimport pandas as pd\n\nlocation_df = pd.read_csv(\"../location_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df\n\n","type":"content","url":"/notebooks/foundations/coordinates#display-coordinates-of-cities","position":23},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Add Columns for Additional Coordinate Types","lvl2":"Convert City Coordinates to All Coordinate Types"},"type":"lvl3","url":"/notebooks/foundations/coordinates#add-columns-for-additional-coordinate-types","position":24},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Add Columns for Additional Coordinate Types","lvl2":"Convert City Coordinates to All Coordinate Types"},"content":"\n\nlocation_df[\"cart_x\"], location_df[\"cart_y\"], location_df[\"cart_z\"] = cartesian_coordinates(location_df[\"latitude\"],\n                                                                                            location_df[\"longitude\"])\nlocation_df[\"rho\"], location_df[\"theta\"], location_df[\"phi\"] = cartesian_to_spherical_coordinates(location_df[\"cart_x\"],\n                                                                                                  location_df[\"cart_y\"],\n                                                                                                  location_df[\"cart_z\"])\nlocation_df[\"polar_x\"], location_df[\"polar_y\"], location_df[\"polar_z\"] = polar_coordinates(location_df[\"latitude\"],\n                                                                                           location_df[\"longitude\"])\n\nlocation_df\n\n# Save Output to a New Text File\nlocation_df.to_csv(\"../location_full_coords.txt\", index=False)\n\n","type":"content","url":"/notebooks/foundations/coordinates#add-columns-for-additional-coordinate-types","position":25},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Plot Coordinates"},"type":"lvl2","url":"/notebooks/foundations/coordinates#plot-coordinates","position":26},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Plot Coordinates"},"content":"\n\n","type":"content","url":"/notebooks/foundations/coordinates#plot-coordinates","position":27},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"World Map","lvl2":"Plot Coordinates"},"type":"lvl3","url":"/notebooks/foundations/coordinates#world-map","position":28},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"World Map","lvl2":"Plot Coordinates"},"content":"Full world map from -180-180 and -90-90:longitude east = 180\n\nlongitude west = -180\n\nlatitude north = 90\n\nlatitude south = -90\n\n# Set up world map plot\nfig = plt.subplots(figsize=(15, 10))\nprojection_map = ccrs.PlateCarree()\nax = plt.axes(projection=projection_map)\nlon_west, lon_east, lat_south, lat_north = -180, 180, -90, 90\nax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\nax.coastlines(color=\"black\")\nax.add_feature(cfeature.BORDERS, edgecolor='grey')\nax.add_feature(cfeature.STATES, edgecolor=\"grey\")\n    \n# Plot Latitude/Longitude Location\nlongitudes = location_df[\"longitude\"] # longitude\nlatitudes = location_df[\"latitude\"]   # latitude\nplt.scatter(longitudes, latitudes, c=\"red\")\n\nplt.title(\"World Map with Locations\")\nplt.show()\n\n","type":"content","url":"/notebooks/foundations/coordinates#world-map","position":29},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"United States Map","lvl2":"Plot Coordinates"},"type":"lvl3","url":"/notebooks/foundations/coordinates#united-states-map","position":30},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"United States Map","lvl2":"Plot Coordinates"},"content":"Map of the United States roughly from -130 to -60 and 20 to 60:longitude east = -60\n\nlongitude west = -130\n\nlatitude north = 60\n\nlatitude south = 20\n\n# Set up United States map plot\nfig = plt.subplots(figsize=(15, 10))\nprojection_map = ccrs.PlateCarree()\nax = plt.axes(projection=projection_map)\nlon_west, lon_east, lat_south, lat_north = -130, -60, 20, 60\nax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\nax.coastlines(color=\"black\")\nax.add_feature(cfeature.BORDERS, edgecolor='grey')\nax.add_feature(cfeature.STATES, edgecolor=\"grey\")\n    \n# Plot Latitude/Longitude Location\nlongitudes = location_df[\"longitude\"] # longitude\nlatitudes = location_df[\"latitude\"]   # latitude\nplt.scatter(longitudes, latitudes, c=\"red\")\n\nplt.title(\"United States Map with Locations\")\nplt.show()\n\n\n\n","type":"content","url":"/notebooks/foundations/coordinates#united-states-map","position":31},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/foundations/coordinates#summary","position":32},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Summary"},"content":"Coordinates on the Earth are measured in many different types of coordinate systems: Geodesic (latitude/longitude), cartesian, spherical, and polar. These coordinates will make future calculations simpler by converting a 2D coordinate like latitude/longitude into a 3D space that can be used for vector calculations.\n\nIn Python, coordinates can be mapped on to a world map via matplotlib and cartopy.","type":"content","url":"/notebooks/foundations/coordinates#summary","position":33},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/foundations/coordinates#whats-next","position":34},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"What’s next?","lvl2":"Summary"},"content":"Great Circle arcs and paths\n\n","type":"content","url":"/notebooks/foundations/coordinates#whats-next","position":35},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/foundations/coordinates#resources-and-references","position":36},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Resources and references"},"content":"\n\nEd Williams “Avitation Formulary”\n\nMovable Type Scripts","type":"content","url":"/notebooks/foundations/coordinates#resources-and-references","position":37},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"type":"lvl1","url":"/notebooks/how-to-cite","position":0},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"content":"The material in this Project Pythia Cookbook is licensed for free and open consumption and reuse. All code is served under \n\nApache 2.0, while all non-code content is licensed under \n\nCreative Commons BY 4.0 (CC BY 4.0). Effectively, this means you are free to share and adapt this material so long as you give appropriate credit to the Cookbook authors and the Project Pythia community.\n\nThe source code for the book is \n\nreleased on GitHub and archived on Zenodo. This DOI will always resolve to the latest release of the book source:\n\n","type":"content","url":"/notebooks/how-to-cite","position":1},{"hierarchy":{"lvl1":"Great Circle Arcs and Path"},"type":"lvl1","url":"/notebooks/tutorials/arc-path","position":0},{"hierarchy":{"lvl1":"Great Circle Arcs and Path"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/arc-path","position":1},{"hierarchy":{"lvl1":"Great Circle Arcs and Path"},"type":"lvl1","url":"/notebooks/tutorials/arc-path#great-circle-arcs-and-path","position":2},{"hierarchy":{"lvl1":"Great Circle Arcs and Path"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/arc-path#great-circle-arcs-and-path","position":3},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#overview","position":4},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Overview"},"content":"Imagine a plane flying from Cario to Hong Kong. To a passenger, the plane appears to travel a straight path, but the plane actually curves around the surface of the Earth held down by the gravity of the planet.\n\nGreat circles are circles that circumnavigate the globe.\n\nDistance between Points on a Great Circle Arc\n\nSpherical Distance to Degrees\n\nDetermine the Bearing of a Great Circle Arc\n\nGenerate a Great Circle Arc with Intermediate Points\n\nDetermine the Midpoint of a Great Circle Arc\n\nGenerate a Great Circle Path\n\nDetermine an Antipodal Point\n\nCompare Great Circle Arc to Rhumb Line (TODO)\n\n","type":"content","url":"/notebooks/tutorials/arc-path#overview","position":5},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#prerequisites","position":6},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 40 minutes\n\n\n\n","type":"content","url":"/notebooks/tutorials/arc-path#prerequisites","position":7},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#imports","position":8},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Imports"},"content":"Import Packages\n\nSetup location dataframe with coordinates\n\nimport pandas as pd       # reading in data for location information from text file\nimport numpy as np        # working with arrays, vectors, cross/dot products, and radians\n\nfrom pyproj import Geod   # working with the Earth as an ellipsod (WGS-84)\nimport geopy.distance     # working with the Earth as an ellipsod\n\n# Get all Coordinates for Locations\nlocation_df = pd.read_csv(\"../location_full_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df.head()\n\nlocation_df.index = location_df[\"name\"]\n\n","type":"content","url":"/notebooks/tutorials/arc-path#imports","position":9},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Distance Between Points on a Great Circle Arc"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#distance-between-points-on-a-great-circle-arc","position":10},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Distance Between Points on a Great Circle Arc"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/arc-path#distance-between-points-on-a-great-circle-arc","position":11},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Distance Between Points Mathematically via Unit Sphere","lvl2":"Distance Between Points on a Great Circle Arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#determine-distance-between-points-mathematically-via-unit-sphere","position":12},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Distance Between Points Mathematically via Unit Sphere","lvl2":"Distance Between Points on a Great Circle Arc"},"content":"Distance between point A (latA, lonA) and point B (latB, lonB):d=acos(sin(latA)*sin(latB)+cos(latA)*cos(latB)*cos(lonA-lonB))\n\nFor shorter distances (with less rounding errors):d=2*asin(\\sqrt{sin(\\frac{latA-latB}{2})^2 + cos(latA)*cos(latB)*sin(\\frac{lonA-lonB}{2})^2})\n\nEd Williams: Distance Between Points\n\ndef distance_between_points_default(start_point=None, end_point=None):\n    earth_radius = 6378137  # meters\n    latA = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lonA = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    latB = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    lonB = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n\n    distance_default = np.arccos(np.sin(latA)*np.sin(latB)+np.cos(latA)*np.cos(latB)*np.cos(lonA-lonB))\n    return distance_default * earth_radius\n\ndef distance_between_points_small(start_point=None, end_point=None):\n    earth_radius = 6378137  # meters\n    latA = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lonA = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    latB = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    lonB = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n\n    distance_small = 2 * np.arcsin(np.sqrt((np.sin((latA-latB)/2))**2 + np.cos(latA)*np.cos(latB)*(np.sin((lonA-lonB)/2))**2))\n    return distance_small * earth_radius\n\nAdditional types of distance measuerments:\n\nHaversine\n\nVincenty Sphere Great Circle Distance\n\nVincenty Ellipsoid Great Circle Distance\n\nMeeus Great Circle Distance\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-distance-between-points-mathematically-via-unit-sphere","position":13},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Distance Points via Python Package pyproj","lvl2":"Distance Between Points on a Great Circle Arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#determine-distance-points-via-python-package-pyproj","position":14},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Distance Points via Python Package pyproj","lvl2":"Distance Between Points on a Great Circle Arc"},"content":"pyproj accounts for different ellipsoids like WGS-84.\n\nFirst, setup a ellipsoid to represent the Earth (“WGS-84”):\n\n# Distance between Boulder and Boston\ngeodesic = Geod(ellps=\"WGS84\")\n_, _, distance_meter =  geodesic.inv(location_df.loc[\"boulder\", \"longitude\"],\n                                     location_df.loc[\"boulder\", \"latitude\"],\n                                     location_df.loc[\"boston\", \"longitude\"],\n                                     location_df.loc[\"boston\", \"latitude\"])\n\nprint(f\"Distance between coordinates (ellipsoid)   = {distance_meter/1000} km\")\ndistance_unit_sphere_default = distance_between_points_default(\"boulder\", \"boston\")\nprint(f\"Distance between coordinates (unit sphere) = {distance_unit_sphere_default/1000} km\")\ndistance_unit_sphere_small = distance_between_points_small(\"boulder\", \"boston\")\nprint(f\"Distance between coordinates (unit sphere) = {distance_unit_sphere_small/1000} km\")\n\nCompared to the distance from the associated airports in Denver and Boston (\n\nDIA to Logan) which has a distance of 2823 km, using Denver instead of Boulder.\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-distance-points-via-python-package-pyproj","position":15},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Spherical Distance to Degrees"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#spherical-distance-to-degrees","position":16},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Spherical Distance to Degrees"},"content":"Convert a distance from meters to degrees, measured along the great circle sphere with a constant spherical radius of ~6371 km (mean radius of Earth).\n\nSee also: \n\nObsPy kilometer2degrees()\n\n# assumes a spherical Earth\nearth_radius = 6378.137 # km\n\ndef km_to_degree_distance(distance_km=None):\n    return distance_km / (2 * earth_radius * np.pi / 360)\n\ndef degree_to_km_distance(distance_degree=None):\n    return distance_degree * (2 * earth_radius * np.pi / 360)\n\nprint(f\"300 km to degrees = {km_to_degree_distance(300)} degrees\")\nprint(f\"6.381307 degree to km = {degree_to_km_distance(6.381307)} km\")\n\n","type":"content","url":"/notebooks/tutorials/arc-path#spherical-distance-to-degrees","position":17},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Determine the Bearing of a Great Circle Arc"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#determine-the-bearing-of-a-great-circle-arc","position":18},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Determine the Bearing of a Great Circle Arc"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-the-bearing-of-a-great-circle-arc","position":19},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine the Bearing Mathematically via Unit Sphere","lvl2":"Determine the Bearing of a Great Circle Arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#determine-the-bearing-mathematically-via-unit-sphere","position":20},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine the Bearing Mathematically via Unit Sphere","lvl2":"Determine the Bearing of a Great Circle Arc"},"content":"Bearing between point A (latA, lonA) and point B (latB, lonB):x = cos(latA) * sin(latB) - sin(latA) * cos(latB) * cos(lonB - lonA)y = sin(lonB - lonA) * cos(latB)θ = atan2(y, x)\n\nMovable Type: Bearing\n\ndef bearing_between_points_unit_sphere(start_point=None, end_point=None):\n    latA = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lonA = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    latB = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    lonB = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n\n    x = np.cos(latA) * np.sin(latB) - np.sin(latA) * np.cos(latB) * np.cos(lonB - lonA)\n    y = np.sin(lonB - lonA) * np.cos(latB)\n    bearing = np.arctan2(y, x)\n    return np.rad2deg(bearing) % 360\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-the-bearing-mathematically-via-unit-sphere","position":21},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine the Bearing via Python Package pyproj","lvl2":"Determine the Bearing of a Great Circle Arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#determine-the-bearing-via-python-package-pyproj","position":22},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine the Bearing via Python Package pyproj","lvl2":"Determine the Bearing of a Great Circle Arc"},"content":"pyproj accounts for different ellipsoids like WGS-84:\n\ndef bearing_between_points_ellps(start_point=None, end_point=None):\n    geodesic = Geod(ellps=\"WGS84\")\n    fwd_bearing, _, _ =  geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                        location_df.loc[start_point, \"latitude\"],\n                                        location_df.loc[end_point, \"longitude\"],\n                                        location_df.loc[end_point, \"latitude\"])\n    return fwd_bearing\n\n### Compare Unit Sphere and Ellipsoid\nbeaing_ellps = bearing_between_points_ellps(\"boulder\", \"boston\")\nprint(f\"forward bearing between coordinates (ellipsoid)   = {beaing_ellps} Degrees\")\nbearing_us = bearing_between_points_unit_sphere(\"boulder\", \"boston\")\nprint(f\"forward bearing between coordinates (unit sphere) = {bearing_us} Degrees\")\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-the-bearing-via-python-package-pyproj","position":23},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#generating-a-great-circle-arc-with-intermediates-points","position":24},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/arc-path#generating-a-great-circle-arc-with-intermediates-points","position":25},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Intermediate Points Mathemetically via Unit Sphere","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#determine-intermediate-points-mathemetically-via-unit-sphere","position":26},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Intermediate Points Mathemetically via Unit Sphere","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"Determine the points (lat, lon) a given fraction of a distance (d) between a starting points A (latA, lonA) and the final point B (latB, lonB) where f is a fraction along the great circle arc. f=0 is point A and f=1 is point B.\n\nNote: The points cannot be antipodal because the path is undefined\n\nWhere, antipodal is defined by:latA + latB = 0\n\nabs(lonA - lonB) = pi\n\nWhere the distance between two points is the angular distance:d = \\frac{\\text{total distance of arc}}{\\text{earth's radius}}\n\nThe intermediate points (lat, lon) along a given path starting point to end point:A = sin(\\frac{(1-f) * d}{sin(d)}B = \\frac{sin(f*d)}{sin(d)}x = A * cos(latA) * cos(lonA) + B * cos(latB) * cos(lonB)y = A * cos(latA) * sin(lonA) + B * cos(latB) * sin(lonB)z = A * sin(latA) + B * sin(latB)lat = atan2(z, \\sqrt{x^2 + y^2})lon = atan2(y, x)\n\nEd Williams: Intermediate Points on a Great Circle\n\nMoveable Type: Intermediate Point\n\ndef intermediate_points(start_point=None, end_point=None,\n                        fraction=None, distance=None):\n    earth_radius = 6378137  # meters\n    total_distance = distance / earth_radius\n    latA = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lonA = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    latB = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    lonB = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n\n    A = np.sin((1-fraction) * total_distance) / np.sin(total_distance)\n    B = np.sin(fraction * total_distance) / np.sin(total_distance)\n    x = (A * np.cos(latA) * np.cos(lonA)) + (B * np.cos(latB) * np.cos(lonB))\n    y = (A * np.cos(latA) * np.sin(lonA)) + (B * np.cos(latB) * np.sin(lonB))\n    z = (A * np.sin(latA)) + (B * np.sin(latB))\n    lat = np.arctan2(z, np.sqrt(x**2 + y**2))\n    lon = np.arctan2(y, x)\n    return (np.rad2deg(lat), np.rad2deg(lon))\n\ndef calculate_intermediate_pts(start_point=None, end_point=None,\n                               fraction=None, total_distance_meter=None):\n    fractions = np.arange(0, 1+fraction, fraction)\n    intermediate_lat_lon = []\n    for fractional in fractions:\n        intermediate_pts = intermediate_points(start_point, end_point,\n                                                fractional, total_distance_meter)\n        intermediate_lat_lon.append(intermediate_pts)\n    return intermediate_lat_lon\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-intermediate-points-mathemetically-via-unit-sphere","position":27},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Intermediate Points via Python Package pyproj and geopy","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#determine-intermediate-points-via-python-package-pyproj-and-geopy","position":28},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Intermediate Points via Python Package pyproj and geopy","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"Interpolate with N total equally spaced number of points\n\nInterpolate every N meters\n\nInterpolate a fractional distance along arc\n\ndef interpolate_points_along_gc(lat_start,\n                                lon_start,\n                                lat_end,\n                                lon_end,\n                                distance_between_points_meter): \n    lat_lon_points = [(lat_start, lon_start)]\n    \n    # move to next point when distance between points is less than the equal distance\n    move_to_next_point = True\n    while(move_to_next_point):\n        forward_bearing, _, distance_meters = geodesic.inv(lon_start,\n                                                            lat_start, \n                                                            lon_end,\n                                                            lat_end)\n        if distance_meters < distance_between_points_meter:\n            # ends before overshooting\n            move_to_next_point = False\n        else:\n            start_point = geopy.Point(lat_start, lon_start)\n            distance_to_move = geopy.distance.distance(\n                            kilometers=distance_between_points_meter /\n                            1000)  # distance to move towards the next point\n            final_position = distance_to_move.destination(\n                            start_point, bearing=forward_bearing)\n            lat_lon_points.append((final_position.latitude, final_position.longitude))\n            # new starting position is newly found end position\n            lon_start, lat_start = final_position.longitude, final_position.latitude\n    lat_lon_points.append((lat_end, lon_end))\n    return lat_lon_points\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-intermediate-points-via-python-package-pyproj-and-geopy","position":29},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#plot-arcs-as-points-on-a-world-map","position":30},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"\n\nimport matplotlib.pyplot as plt\nfrom cartopy import crs as ccrs, feature as cfeature\n\ndef plot_coordinate(lst_of_coords=None, title=None):\n    # Set up world map plot on the United States\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    lon_west, lon_east, lat_south, lat_north = -130, -60, 20, 60\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n    \n    # Plot Latitude/Longitude Location\n    longitudes = [x[1] for x in lst_of_coords] # longitude\n    latitudes = [x[0] for x in lst_of_coords] # latitude\n    plt.plot(longitudes, latitudes)\n    plt.scatter(longitudes, latitudes)\n    \n    # Setup Axis Limits and Title/Labels\n    plt.title(title)\n    plt.show()\n\n","type":"content","url":"/notebooks/tutorials/arc-path#plot-arcs-as-points-on-a-world-map","position":31},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Interpolate with N Total Equally Spaced Points","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl4","url":"/notebooks/tutorials/arc-path#interpolate-with-n-total-equally-spaced-points","position":32},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Interpolate with N Total Equally Spaced Points","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"\n\nn_total_points = 10 # total points (n points)\ndistance_between_points_meter = distance_meter / (n_total_points + 1)\nprint(f\"Each point will be separated by {distance_between_points_meter} meters ({distance_between_points_meter/1000} km)\")\n\nlat_start, lon_start = location_df.loc[[\"boulder\"]][\"latitude\"].iloc[0], location_df.loc[[\"boulder\"]][\"longitude\"].iloc[0]\nlat_end, lon_end = location_df.loc[[\"boston\"]][\"latitude\"].iloc[0], location_df.loc[[\"boston\"]][\"longitude\"].iloc[0]\n\nintermediate_geodesic = interpolate_points_along_gc(lat_start,\n                                          lon_start,\n                                          lat_end,\n                                          lon_end,\n                                          distance_between_points_meter)\nprint(f\"{len(intermediate_geodesic)} Total Points\")\nintermediate_geodesic\n\nplot_coordinate(intermediate_geodesic,\n                title=f\"Interpolate {n_total_points} Points\")\n\n","type":"content","url":"/notebooks/tutorials/arc-path#interpolate-with-n-total-equally-spaced-points","position":33},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Interpolate every N meters","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl4","url":"/notebooks/tutorials/arc-path#interpolate-every-n-meters","position":34},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Interpolate every N meters","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"\n\ndistance_between_points_meter = 112000\nprint(f\"Each point will be separated by {distance_between_points_meter} meters ({distance_between_points_meter/1000} km)\")\n\nlat_start, lon_start = location_df.loc[\"boulder\", \"latitude\"], location_df.loc[\"boulder\", \"longitude\"]\nlat_end, lon_end = location_df.loc[\"boston\", \"latitude\"], location_df.loc[\"boston\", \"longitude\"]\n\nintermediate_geodesic = interpolate_points_along_gc(lat_start,\n                                          lon_start,\n                                          lat_end,\n                                          lon_end,\n                                          distance_between_points_meter)\nprint(f\"{len(intermediate_geodesic)} Total Points\")\nintermediate_geodesic\n\nplot_coordinate(intermediate_geodesic,\n                title=f\"Interpolate every {distance_between_points_meter/1000} km\")\n\n","type":"content","url":"/notebooks/tutorials/arc-path#interpolate-every-n-meters","position":35},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Interpolate a fractional distance along arc","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl4","url":"/notebooks/tutorials/arc-path#interpolate-a-fractional-distance-along-arc","position":36},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Interpolate a fractional distance along arc","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"\n\nfraction = 1/10\n\ndistance_between_points_meter = fraction * distance_meter\nprint(f\"Each point will be separated by {distance_between_points_meter} meters ({distance_between_points_meter/1000} km)\")\n\nlat_start, lon_start = location_df.loc[\"boulder\", \"latitude\"], location_df.loc[\"boulder\", \"longitude\"]\nlat_end, lon_end = location_df.loc[\"boston\", \"latitude\"], location_df.loc[\"boston\", \"longitude\"]\n\nintermediate_ellipsoid = interpolate_points_along_gc(lat_start,\n                                          lon_start,\n                                          lat_end,\n                                          lon_end,\n                                          distance_between_points_meter)\nprint(f\"{len(intermediate_ellipsoid)} Total Points\")\nintermediate_ellipsoid\n\nplot_coordinate(intermediate_ellipsoid,\n                title=f\"(Ellipsoid) Interpolate on Fraction {fraction}\")\n\ndistance_unit_sphere_default = distance_between_points_default(\"boulder\", \"boston\")\nintermediate_unit_sphere = calculate_intermediate_pts(\"boulder\", \"boston\",\n                                               fraction, distance_unit_sphere_default)\nprint(f\"{len(intermediate_unit_sphere)} Total Points\")\nintermediate_unit_sphere\n\nplot_coordinate(intermediate_unit_sphere,\n                title=f\"(Unit Sphere) Interpolate on Fraction {fraction}\")\n\n# compare math and geodesic outputs\nfor i in range(len(intermediate_ellipsoid)):\n    _, _, distance_m = geodesic.inv(intermediate_ellipsoid[i][0], intermediate_ellipsoid[i][1],\n                                   intermediate_unit_sphere[i][0], intermediate_unit_sphere[i][1])\n    if np.isnan(distance_m): distance_m = 0\n    print(f\"Distance between ellipsoid/unit sphere defined point {i}: {distance_m} meters\")\n\n","type":"content","url":"/notebooks/tutorials/arc-path#interpolate-a-fractional-distance-along-arc","position":37},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Determine the Midpoint of a Great Circle Arc"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#determine-the-midpoint-of-a-great-circle-arc","position":38},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Determine the Midpoint of a Great Circle Arc"},"content":"\n\nThe midpoint of an arc can be determiend as a fractional distance along an arc where f = 0.5.\n\nmidpoint = distance_meter / 2\nlat_start, lon_start = location_df.loc[\"boulder\", \"latitude\"], location_df.loc[\"boulder\", \"longitude\"]\nlat_end, lon_end = location_df.loc[\"boston\", \"latitude\"], location_df.loc[\"boston\", \"longitude\"]\n\nintermediate_geodesic = interpolate_points_along_gc(lat_start,\n                                          lon_start,\n                                          lat_end,\n                                          lon_end,\n                                          midpoint)\nprint(f\"{len(intermediate_geodesic)} Total Points\")\nprint(intermediate_geodesic)\nprint(f\"Midpoint = {intermediate_geodesic[1]}\")\n\ndistance_unit_sphere_default = distance_between_points_default(\"boulder\", \"boston\")\nintermediate_unit_sphere = calculate_intermediate_pts(\"boulder\", \"boston\",\n                                               1/2, distance_unit_sphere_default)\nprint(f\"{len(intermediate_unit_sphere)} Total Points\")\nprint(intermediate_unit_sphere)\nprint(f\"Midpoint = {intermediate_unit_sphere[1]}\")\n\n# Compare geodesic and unit sphere\n_, _, distance_m = geodesic.inv(intermediate_geodesic[1][0], intermediate_geodesic[1][1],\n                                   intermediate_unit_sphere[1][0], intermediate_unit_sphere[1][1])\nprint(f\"Distance between geodesic/unint sphere defined midpoint = {distance_m} meters\")\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-the-midpoint-of-a-great-circle-arc","position":39},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Generate a Great Circle Path"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#generate-a-great-circle-path","position":40},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Generate a Great Circle Path"},"content":"Generate points along a great circle path bewtween two points.\n\n# Generate Latitude Coordinates based on Longitude Coordinates\ndef generate_latitude_along_gc(start_point=None, end_point=None, number_of_lon_pts=360):\n    lat1 = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lon1 = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    lat2 = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    lon2 = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n\n    # Verify not meridian (longitude passes through the poles)\n    if np.sin(lon1 - lon2) == 0:\n        print(\"Invalid inputs: start/end points are meridians\")\n        # plotting meridians at 0 longitude through all latitudes\n        meridian_lat = np.arange(-90, 90, 180/len(longitude_lst)) # split in n number\n        meridians = []\n        for lat in meridian_lat:\n            meridians.append((lat, 0))\n        return meridians\n\n    # verify not anitpodal (diametrically opposite, points)\n    if lat1 + lat2 == 0 and abs(lon1-lon2) == np.pi:\n        print(\"Invalid inputs: start/end points are antipodal\")\n        return []\n\n    # note: can be expanded to handle input of np arrays by filter out antipodal/merdiain points\n\n    # generate n total number of longitude points along the great circle\n    # https://github.com/rspatial/geosphere/blob/master/R/greatCircle.R#L18C3-L18C7\n    gc_lon_lst = []\n    for lon in range(1, number_of_lon_pts+1):\n        new_lon = (lon  * (360/number_of_lon_pts) - 180)\n        gc_lon_lst.append(np.deg2rad(new_lon))\n\n    # Intermediate points on a great circle: https://edwilliams.org/avform147.htm\"\n    gc_lat_lon = []\n    for gc_lon in gc_lon_lst:\n        num = np.sin(lat1)*np.cos(lat2)*np.sin(gc_lon-lon2)-np.sin(lat2)*np.cos(lat1)*np.sin(gc_lon-lon1)\n        den = np.cos(lat1)*np.cos(lat2)*np.sin(lon1-lon2)\n        new_lat = np.arctan(num/den)\n        gc_lat_lon.append((np.rad2deg(new_lat), np.rad2deg(gc_lon)))\n    return gc_lat_lon\n\ndef arc_points(start_lat=None,\n               start_lon=None,\n               end_lat=None,\n               end_lon=None,\n               n_total_points=10):\n    _, _, distance_meter =  geodesic.inv(start_lon,\n                                        start_lat,\n                                        end_lon,\n                                        end_lat)\n        \n    distance_between_points_meter = distance_meter / (n_total_points + 1)\n\n    \n    points_along_arc = interpolate_points_along_gc(start_lat,\n                                              start_lon,\n                                              end_lat,\n                                              end_lon,\n                                              distance_between_points_meter)\n    return points_along_arc\n\ndef plot_coordinate(lat_lon_lst=None,\n                    start_point=None, end_point=None,\n                    title=None):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    lon_west, lon_east, lat_south, lat_north = -180, 180, -90, 90\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.BORDERS, edgecolor='grey')\n    ax.add_feature(cfeature.STATES, edgecolor=\"grey\")\n        \n    # Plot Latitude/Longitude Location of great circle path\n    longitudes = [x[1] for x in lat_lon_lst] # longitude\n    latitudes = [x[0] for x in lat_lon_lst] # latitude\n    plt.plot(longitudes, latitudes, c=\"cornflowerblue\")\n    plt.scatter(longitudes, latitudes, c=\"cornflowerblue\")\n\n    # Overly great circle with arc rom start/end point\n    start_end_lat_lon = arc_points(location_df.loc[start_point, \"latitude\"],\n                                   location_df.loc[start_point, \"longitude\"],\n                                   location_df.loc[end_point, \"latitude\"],\n                                   location_df.loc[end_point, \"longitude\"],\n                                   n_total_points=20)\n    longitudes = [x[1] for x in start_end_lat_lon] # longitude\n    latitudes = [x[0] for x in start_end_lat_lon] # latitude\n    plt.plot(longitudes, latitudes, c=\"red\")\n    plt.scatter(longitudes, latitudes, c=\"red\")\n    \n    # Setup Axis Limits and Title/Labels\n    plt.title(title)\n    plt.show()\n\nstart_pt = \"boulder\"\nend_pt = \"boston\"\nn_pts = 360\nlat_lon_pts = generate_latitude_along_gc(start_pt, end_pt, number_of_lon_pts=n_pts)\nplot_coordinate(lat_lon_pts, start_pt, end_pt,\n                f\"Plot Great Circle, made from the arc {start_pt.title()} to {end_pt.title()}\")\n\nstart_pt = \"arecibo\"\nend_pt = \"greenwich\"\nn_pts = 360\nlat_lon_pts = generate_latitude_along_gc(start_pt, end_pt, number_of_lon_pts=n_pts)\nplot_coordinate(lat_lon_pts, start_pt, end_pt,\n                f\"Plot Great Circle, made from the arc {start_pt.title()} to {end_pt.title()}\")\n\nstart_pt = \"zambezi\"\nend_pt = \"svalbard\"\nn_pts = 360\nlat_lon_pts = generate_latitude_along_gc(start_pt, end_pt, number_of_lon_pts=n_pts)\nplot_coordinate(lat_lon_pts, start_pt, end_pt,\n                f\"Plot Great Circle, made from the arc {start_pt.title()} to {end_pt.title()}\")\n\n","type":"content","url":"/notebooks/tutorials/arc-path#generate-a-great-circle-path","position":41},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Determine an Antipodal Point"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#determine-an-antipodal-point","position":42},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Determine an Antipodal Point"},"content":"Antipodal is the point on the globe that is on the exact opposite side of the Earth.\n\nAntipodal latitude is defined as:\\text{antipodal latitude} = -1 * \\text{latitude}\n\nAntipodal longitude is defined as:\\text{anitpodal longitude} = (\\text{longitude} + 180) \\text{ if longitude} \\le 0\\text{anitpodal longitude} = (\\text{longitude} - 180) \\text{ if longitude} \\gt 0\n\nAntipodes Map\n\ndef antipodal(start_point=None):\n    anti_lat = -1 * location_df.loc[start_point, \"latitude\"]\n    ref_lon = location_df.loc[start_point, \"longitude\"]\n    if ref_lon > 0:\n        anti_lon = ref_lon - 180\n    else:\n        anti_lon = ref_lon + 180\n    #if anti_lon >= 180:\n    #    anti_lon = -1 * (anti_lon % 180)\n    return (anti_lat, anti_lon)\n\ndef is_antipodal(start_point=None, end_point=None):\n    lon1 = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    lat1 = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lon2 = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n    lat2 = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    return lat1 + lat2 == 0 and abs(lon1-lon2) == np.pi\n\ndef plot_antipodal(start_point=None):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    lon_west, lon_east, lat_south, lat_north = -180, 180, -90, 90\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.BORDERS, edgecolor='grey')\n    ax.add_feature(cfeature.STATES, edgecolor=\"grey\")\n        \n    # Plot Start point\n    plt.scatter(location_df.loc[start_point, \"longitude\"],\n                location_df.loc[start_point, \"latitude\"],\n                s=100, c=\"cornflowerblue\", label=start_point.title())\n\n    # Plot Antipodal Point\n    antipodal_point = antipodal(start_point)\n    plt.scatter(antipodal_point[1], antipodal_point[0], s=100, c=\"red\", label=\"Antipodal\")\n    \n    # Setup Axis Limits and Title/Labels\n    plt.title(f\"{start_point.title()} and Antipodal Point {antipodal_point}\")\n    plt.legend(loc=\"lower right\")\n    plt.show()\n\nprint(antipodal(\"boulder\"))\nplot_antipodal(\"boulder\")\n\nprint(antipodal(\"svalbard\"))\nplot_antipodal(\"svalbard\")\n\nprint(antipodal(\"cairo\"))\nplot_antipodal(\"cairo\")\n\n\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-an-antipodal-point","position":43},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#summary","position":44},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Summary"},"content":"Calculating and mapping the midpoint and intermediate points along the great circle arc and closed circle path.","type":"content","url":"/notebooks/tutorials/arc-path#summary","position":45},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#whats-next","position":46},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"What’s next?","lvl2":"Summary"},"content":"With a great circle arc defined, determine if a third point is along the arc or at what distance it sits from the great circle arc and path.\n\n","type":"content","url":"/notebooks/tutorials/arc-path#whats-next","position":47},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#resources-and-references","position":48},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Resources and references"},"content":"\n\nEd Williams “Avitation Formulary”\n\nMovable Type Scripts","type":"content","url":"/notebooks/tutorials/arc-path#resources-and-references","position":49},{"hierarchy":{"lvl1":"Great Circles and a Point"},"type":"lvl1","url":"/notebooks/tutorials/arc-to-point","position":0},{"hierarchy":{"lvl1":"Great Circles and a Point"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point","position":1},{"hierarchy":{"lvl1":"Great Circles and a Point"},"type":"lvl1","url":"/notebooks/tutorials/arc-to-point#great-circles-and-a-point","position":2},{"hierarchy":{"lvl1":"Great Circles and a Point"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#great-circles-and-a-point","position":3},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#overview","position":4},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Overview"},"content":"A plane traveling across the country suddenly discovers it is low on fuel! It can no longer make it to the planned airport, instead it has to find the closest airport to its current position that it can make it with its remaining fuel.\n\nDetermine the distance of a point to a great circle arc (cross-track and along-track distance)\n\nDetermine if a point lies on a great circle arc and path (with and without tolerances)\n\nDetermine the distance of a point to a great circle path (TODO)\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#overview","position":5},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#prerequisites","position":6},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 30 Minutes\n\n\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#prerequisites","position":7},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#imports","position":8},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Imports"},"content":"Import Packages\n\nSetup location dataframe with coordinates\n\nimport pandas as pd                                    # read in data text file\nimport numpy as np                                     # working with degrees and radians\n\nfrom pyproj import Geod                                # working with the Earth as an ellipsod (WGS-84)\nimport geopy.distance                                  # moving along a known distance on the Earth's ellipsoid surface\n\nimport matplotlib.pyplot as plt                        # plotting a graph\nfrom cartopy import crs as ccrs, feature as cfeature   # plotting a world map\n\n# Get all Coordinates for Locations\nlocation_df = pd.read_csv(\"../location_full_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df.index = location_df[\"name\"]\nlocation_df.head()\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#imports","position":9},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Determine the distance of a point to a great circle arc"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#determine-the-distance-of-a-point-to-a-great-circle-arc","position":10},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Determine the distance of a point to a great circle arc"},"content":"The cross-track distance, sometimes known as cross track error, determines the distance from a point to a great circle arc and can be determined with vectors (typically simpler too).\n\ngeodesic = Geod(ellps=\"WGS84\")\nearth_radius = 6378137  # meters\n\nCross track distance: angular distance from point P to great circle path\n\nAlong track distance: angular distance along the great circle path from A to B before hitting a point that is closest to point P\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#determine-the-distance-of-a-point-to-a-great-circle-arc","position":11},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"Cross Track Distance","lvl2":"Determine the distance of a point to a great circle arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-to-point#cross-track-distance","position":12},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"Cross Track Distance","lvl2":"Determine the distance of a point to a great circle arc"},"content":"Distance of a point to a great circle arc is defined as:dxt = asin( sin(δ13) ⋅ sin(θ13 − θ12) ) * R\n\nδ13 (delta_13) is (angular) distance from start point to third point\n\nθ13 (theta_13) is (initial) bearing from start point to third point\n\nθ12 (theta_12) is (initial) bearing from start point to end point\n\nR is the earth’s radiusd_xt = np.arcsin(np.sin(delta_13)*np.sin(theta_13 - theta_12)) * RXTD =asin(sin(dist_AD)*sin(crs_AD-crs_AB))\n\nPositive Cross-Track Distance: Point lies in the hemisphere to the left of the great circle\n\nNegative Cross-Track Distance: Point lies in the hemiphere to the right of the great circle\n\nIf the point A is the N. or S. Pole replace crs_AD-crs_AB with\nlon_D-lon_B or lon_B-lon_D, respectively\n\ndef cross_track_distance(start_point=None, end_point=None, new_point=None):\n    fwd_bearing_start_end, _, _ = geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                               location_df.loc[start_point, \"latitude\"],\n                                               location_df.loc[end_point, \"longitude\"],\n                                               location_df.loc[end_point, \"latitude\"])\n    fwd_bearing_start_new, _, distance_m_start_new = geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                                                  location_df.loc[start_point, \"latitude\"],\n                                                                  location_df.loc[new_point, \"longitude\"],\n                                                                  location_df.loc[new_point, \"latitude\"]) \n\n    angular_distance_start_new = distance_m_start_new / earth_radius\n    ct_distance = np.arcsin(np.sin(angular_distance_start_new) * np.sin(np.deg2rad(fwd_bearing_start_new - fwd_bearing_start_end))) * earth_radius\n    return ct_distance\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#cross-track-distance","position":13},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"Along Track Distance","lvl2":"Determine the distance of a point to a great circle arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-to-point#along-track-distance","position":14},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"Along Track Distance","lvl2":"Determine the distance of a point to a great circle arc"},"content":"Distance along a great circle arc, closest to a point is defined as:dat = acos(\\frac{cos(δ13)}{cos(δxt)}) * R\n\nδ13 (delta_13) is (angular) distance from start point to third point\n\nδxt (delta_xt) is (angular) cross-track distance\n\nR is the earth’s radiusd_at = np.arccos(\\frac{np.cos(delta_13)}{np.cos(d_xt/R)} * RATD=acos(\\frac{cos(dist_AD)}{cos(XTD)})\n\nFor very short distances (is less susceptible to rounding error):ATD=asin(\\sqrt{\\frac{sin(dist_AD))^2 - (sin(XTD))^2 )}{cos(XTD)}}\n\ndef along_track_distance(start_point=None, end_point=None, new_point=None):\n    crosst_distance = cross_track_distance(start_point, end_point, new_point)\n\n    _, _, distance_m_start_new = geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                              location_df.loc[start_point, \"latitude\"],\n                                              location_df.loc[new_point, \"longitude\"],\n                                              location_df.loc[new_point, \"latitude\"])  \n    angular_distance_start_new = distance_m_start_new / earth_radius\n    at_distance = np.arccos(np.cos(angular_distance_start_new) / np.cos(crosst_distance / earth_radius)) * earth_radius\n    return at_distance\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#along-track-distance","position":15},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"Generate Points at Intermediate Points along an Arc/Path","lvl2":"Determine the distance of a point to a great circle arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-to-point#generate-points-at-intermediate-points-along-an-arc-path","position":16},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"Generate Points at Intermediate Points along an Arc/Path","lvl2":"Determine the distance of a point to a great circle arc"},"content":"\n\n# Distance point along great circle path\ndef point_along_path(start_point=None, end_point=None, distance_m=None):\n    fwd_bearing, _, _ = geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                     location_df.loc[start_point, \"latitude\"],\n                                     location_df.loc[end_point, \"longitude\"],\n                                     location_df.loc[end_point, \"latitude\"])  \n    origin = geopy.Point(location_df.loc[start_point, \"latitude\"],\n                         location_df.loc[start_point, \"longitude\"])\n    distance_to_move = geopy.distance.distance(\n                            kilometers=distance_m / 1000)  # distance to move towards the next point\n    final_position = distance_to_move.destination(origin, bearing=fwd_bearing)\n    return (final_position.latitude, final_position.longitude)\n\ndef interpolate_points_along_gc(lat_start,\n                                lon_start,\n                                lat_end,\n                                lon_end,\n                                distance_between_points_meter): \n    lat_lon_points = [(lat_start, lon_start)]\n    \n    # move to next point when distance between points is less than the equal distance\n    move_to_next_point = True\n    while(move_to_next_point):\n        forward_bearing, reverse_bearing, distance_meters = geodesic.inv(lon_start,\n                                                                         lat_start, \n                                                                         lon_end,\n                                                                         lat_end)\n        if distance_meters < distance_between_points_meter:\n            # ends before overshooting\n            move_to_next_point = False\n        else:\n            start_point = geopy.Point(lat_start, lon_start)\n            distance_to_move = geopy.distance.distance(\n                            kilometers=distance_between_points_meter /\n                            1000)  # distance to move towards the next point\n            final_position = distance_to_move.destination(\n                            start_point, bearing=forward_bearing)\n            lat_lon_points.append((final_position.latitude, final_position.longitude))\n            # new starting position is newly found end position\n            lon_start, lat_start = final_position.longitude, final_position.latitude\n    lat_lon_points.append((lat_end, lon_end))\n    return lat_lon_points\n\ndef arc_points(start_lat=None,\n               start_lon=None,\n               end_lat=None,\n               end_lon=None,\n               n_total_points=10):\n    _, _, distance_meter =  geodesic.inv(start_lon,\n                                        start_lat,\n                                        end_lon,\n                                        end_lat)\n        \n    distance_between_points_meter = distance_meter / (n_total_points + 1)\n\n    \n    new_points_lst = interpolate_points_along_gc(start_lat,\n                                              start_lon,\n                                              end_lat,\n                                              end_lon,\n                                              distance_between_points_meter)\n    return new_points_lst\n\ndef plot_cross_track(start_point=None, end_point=None, new_point=None,\n                     lon_west=-130, lon_east=-60,\n                     lat_south=20, lat_north=60):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(16, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.BORDERS, edgecolor='grey')\n    ax.add_feature(cfeature.STATES, edgecolor=\"grey\")\n\n    # Cross-Track and Along-Track Distances\n    ct_distance = cross_track_distance(start_point, end_point, new_point)\n    print(f\"Cross Track Distance: \\n{ct_distance} meters ({ct_distance/1000} km)\")\n\n    at_distance = along_track_distance(start_point, end_point, new_point)\n    print(f\"Along Track Distance: \\n{at_distance} meters ({at_distance/1000} km)\\n\")\n\n    closest_point = point_along_path(start_point, end_point, at_distance)\n    print(f\"Closest Point To Point Along Great Circle Path:\\n{closest_point}\") \n\n    # Plot Latitude/Longitude Location\n    great_circle_arc_pts = arc_points(location_df.loc[start_point, \"latitude\"],\n                                      location_df.loc[start_point, \"longitude\"],\n                                      location_df.loc[end_point, \"latitude\"],\n                                      location_df.loc[end_point, \"longitude\"],\n                                      10)\n    longitudes = [x[1] for x in great_circle_arc_pts] # longitude\n    latitudes = [x[0] for x in great_circle_arc_pts] # latitude\n    plt.plot(longitudes, latitudes, c=\"purple\")\n    plt.scatter(longitudes, latitudes, c=\"purple\")\n\n    cross_track_arc = arc_points(closest_point[0],\n                                 closest_point[1],\n                                 location_df.loc[new_point, \"latitude\"],\n                                 location_df.loc[new_point, \"longitude\"],\n                                   10)\n    longitudes = [x[1] for x in cross_track_arc] # longitude\n    latitudes = [x[0] for x in cross_track_arc] # latitude\n    plt.plot(longitudes, latitudes, c=\"green\")\n    plt.scatter(longitudes, latitudes, c=\"green\")\n\n    # plot closest_point in red\n    plt.scatter(closest_point[1], closest_point[0], c=\"red\")\n\n    plt.title(f\"Closest Point {closest_point} from {start_point.title()}->{end_point.title()} to {new_point.title()}, Cross-Track Distance = {ct_distance/1000:4f} km\")\n    plt.show()\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#generate-points-at-intermediate-points-along-an-arc-path","position":17},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl4":"Positive Cross-Track Distance: Point lies in the hemisphere to the left of the great circle","lvl3":"Generate Points at Intermediate Points along an Arc/Path","lvl2":"Determine the distance of a point to a great circle arc"},"type":"lvl4","url":"/notebooks/tutorials/arc-to-point#positive-cross-track-distance-point-lies-in-the-hemisphere-to-the-left-of-the-great-circle","position":18},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl4":"Positive Cross-Track Distance: Point lies in the hemisphere to the left of the great circle","lvl3":"Generate Points at Intermediate Points along an Arc/Path","lvl2":"Determine the distance of a point to a great circle arc"},"content":"\n\nplot_cross_track(start_point=\"boulder\", end_point=\"greenwich\", new_point=\"greenwich\")\n\nplot_cross_track(start_point=\"boulder\", end_point=\"boston\", new_point=\"cape canaveral\")\n\nplot_cross_track(start_point=\"boulder\", end_point=\"boston\", new_point=\"arecibo\",\n                lat_south=15)\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#positive-cross-track-distance-point-lies-in-the-hemisphere-to-the-left-of-the-great-circle","position":19},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl4":"Negative Cross-Track Distance: Point lies in the hemiphere to the right of the great circle","lvl3":"Generate Points at Intermediate Points along an Arc/Path","lvl2":"Determine the distance of a point to a great circle arc"},"type":"lvl4","url":"/notebooks/tutorials/arc-to-point#negative-cross-track-distance-point-lies-in-the-hemiphere-to-the-right-of-the-great-circle","position":20},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl4":"Negative Cross-Track Distance: Point lies in the hemiphere to the right of the great circle","lvl3":"Generate Points at Intermediate Points along an Arc/Path","lvl2":"Determine the distance of a point to a great circle arc"},"content":"\n\nplot_cross_track(start_point=\"boulder\", end_point=\"boston\", new_point=\"redwoods\")\n\nplot_cross_track(start_point=\"boulder\", end_point=\"boston\", new_point=\"greenwich\",\n                lon_east=15)\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#negative-cross-track-distance-point-lies-in-the-hemiphere-to-the-right-of-the-great-circle","position":21},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Determine if a point lies on a great circle arc and path"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#determine-if-a-point-lies-on-a-great-circle-arc-and-path","position":22},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Determine if a point lies on a great circle arc and path"},"content":"With and without tolerances (in meters):\n\ndef is_point_on_arc(start_point=None, end_point=None,\n                check_point=None, tolerance=0):\n    # tolerance in meters\n    lon1 = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    lat1 = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lon2 = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n    lat2 = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    check_lon = np.deg2rad(location_df.loc[check_point, \"longitude\"])\n    check_lat = np.deg2rad(location_df.loc[check_point, \"latitude\"])\n\n    # Verify not meridian (longitude passes through the poles)\n    if np.sin(lon1 - lon2) == 0:\n        print(\"Invalid inputs: start/end points are meridians\")\n        return np.nan\n    \n    # verify not anitpodal (diametrically opposite, points)\n    if lat1 + lat2 == 0 and abs(lon1-lon2) == np.pi:\n        print(\"Invalid inputs: start/end points are antipodal\")\n        return np.nan\n    # account for tolerance based on cross-track distance from arc\n    ct_distance = cross_track_distance(start_point, end_point, check_point)\n    print(f\"Cross-Track Distance = {ct_distance} meters\")\n    if np.abs(ct_distance) <= tolerance:\n        return True\n\n    # determine expected latitude\n    num = np.sin(lat1)*np.cos(lat2)*np.sin(check_lon-lon2)-np.sin(lat2)*np.cos(lat1)*np.sin(check_lon-lon1)\n    den = np.cos(lat1)*np.cos(lat2)*np.sin(lon1-lon2)\n    new_lat = np.arctan(num/den)\n    expected_lat = np.rad2deg(new_lat)\n    return check_lat == expected_lat\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#determine-if-a-point-lies-on-a-great-circle-arc-and-path","position":23},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl4":"Check if a point lies on a great circle arc","lvl2":"Determine if a point lies on a great circle arc and path"},"type":"lvl4","url":"/notebooks/tutorials/arc-to-point#check-if-a-point-lies-on-a-great-circle-arc","position":24},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl4":"Check if a point lies on a great circle arc","lvl2":"Determine if a point lies on a great circle arc and path"},"content":"\n\nis_point_on_arc(\"boulder\", \"boston\", \"rockford\", tolerance=0)\n\nplot_cross_track(start_point=\"boulder\", end_point=\"boston\", new_point=\"rockford\")\n\nplot_cross_track(start_point=\"boulder\", end_point=\"boston\", new_point=\"rockford\", \n                 lon_west=-95, lon_east=-85,\n                 lat_south=40, lat_north=45)\n\n# increase tolerance to capture point\nprint(\"tolerance = 0\")\nprint(is_point_on_arc(\"boulder\", \"boston\", \"rockford\", tolerance=0))\nprint(\"\\ntolerance >= cross-track distance\")\nprint(is_point_on_arc(\"boulder\", \"boston\", \"rockford\", tolerance=18202))\n\n\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#check-if-a-point-lies-on-a-great-circle-arc","position":25},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#summary","position":26},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Summary"},"content":"Calculating and plotting the cross-track and along-trackd distance of a great circle arc/path and a point.","type":"content","url":"/notebooks/tutorials/arc-to-point#summary","position":27},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/tutorials/arc-to-point#whats-next","position":28},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"What’s next?","lvl2":"Summary"},"content":"Determine when a great circle path crosses a given parallel and the maximum and minimum latitude coordinates of a great circle path.\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#whats-next","position":29},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#resources-and-references","position":30},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Resources and references"},"content":"\n\nAviation Formulary V1.47\n\nMoveable Type Script","type":"content","url":"/notebooks/tutorials/arc-to-point#resources-and-references","position":31},{"hierarchy":{"lvl1":"Great Circles and Parallels"},"type":"lvl1","url":"/notebooks/tutorials/parallels-max-min","position":0},{"hierarchy":{"lvl1":"Great Circles and Parallels"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min","position":1},{"hierarchy":{"lvl1":"Great Circles and Parallels"},"type":"lvl1","url":"/notebooks/tutorials/parallels-max-min#great-circles-and-parallels","position":2},{"hierarchy":{"lvl1":"Great Circles and Parallels"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#great-circles-and-parallels","position":3},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#overview","position":4},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Overview"},"content":"A valid great circle path (that is not a path around the equator) will cross a maximum and minimum latitude.\n\nDetermine the maximum latitude on a Great Circle Path\n\nDetermine the minimum latitude on a Great Great path\n\nDetermine when a great circle path crosses parallels (TODO)\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#overview","position":5},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#prerequisites","position":6},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 30 minutes\n\n\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#prerequisites","position":7},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#imports","position":8},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Imports"},"content":"Import Packages\n\nSetup location dataframe with coordinates\n\nimport pandas as pd       # reading in data for location information from text file\nimport numpy as np        # working with arrays, vectors, cross/dot products, and radians\n\nfrom pyproj import Geod   # working with the Earth as an ellipsod (WGS-84)\n\nimport matplotlib.pyplot as plt                        # plotting a graph\nfrom cartopy import crs as ccrs, feature as cfeature   # plotting a world map\n\n# Get all Coordinates for Locations\nlocation_df = pd.read_csv(\"../location_full_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df.head()\n\nlocation_df.index = location_df[\"name\"]\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#imports","position":9},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Maximum Latitude on a Great Circle Path"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#maximum-latitude-on-a-great-circle-path","position":10},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Maximum Latitude on a Great Circle Path"},"content":"\n\nWe have previously determined an equation to derive a great circle path from intermediate points from two points on a great circle arc.\n\nWithout additional calculations, we can use a list of points along the great circle path to find the maximum location of the maximum and minimum.\n\nBy default, the equation below will determine 360 points along longitude, so the output will only have a resolution of 1 degree. However, by defining the longitude with more points, the resolution increases.\n\n# Generate Latitude Coordinates based on Longitude Coordinates\ndef generate_latitude_along_gc(start_point=None, end_point=None, number_of_lon_pts=360):\n    lon1 = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    lat1 = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lon2 = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n    lat2 = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n\n    # Verify not meridian (longitude passes through the poles)\n    if np.sin(lon1 - lon2) == 0:\n        print(\"Invalid inputs: start/end points are meridians\")\n        # plotting meridians at 0 longitude through all latitudes\n        meridian_lat = np.arange(-90, 90, 180/len(longitude_lst)) # split in n number\n        meridians = []\n        for lat in meridian_lat:\n            meridians.append((lat, 0))\n        return meridians\n\n    # verify not anitpodal (diametrically opposite, points)\n    if lat1 + lat2 == 0 and abs(lon1-lon2) == np.pi:\n        print(\"Invalid inputs: start/end points are antipodal\")\n        return []\n\n    # note: can be expanded to handle input of np arrays by filter out antipodal/merdiain points\n\n    # generate n total number of longitude points along the great circle\n    # https://github.com/rspatial/geosphere/blob/master/R/greatCircle.R#L18C3-L18C7\n    gc_lon_lst = []\n    for lon in range(1, number_of_lon_pts+1):\n        new_lon = (lon  * (360/number_of_lon_pts) - 180)\n        gc_lon_lst.append(np.deg2rad(new_lon))\n\n    # Intermediate points on a great circle: https://edwilliams.org/avform147.htm\"\n    gc_lat_lon = []\n    for gc_lon in gc_lon_lst:\n        num = np.sin(lat1)*np.cos(lat2)*np.sin(gc_lon-lon2)-np.sin(lat2)*np.cos(lat1)*np.sin(gc_lon-lon1)\n        den = np.cos(lat1)*np.cos(lat2)*np.sin(lon1-lon2)\n        new_lat = np.arctan(num/den)\n        gc_lat_lon.append((np.rad2deg(new_lat), np.rad2deg(gc_lon)))\n    return gc_lat_lon\n\nlat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=360)\nprint(f\"Max Latitude (within 1 degree): {max(lat_lon, key=lambda x:x[0])}\")\n\nlat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=720)\nprint(f\"Max Latitude (within 0.5 degree): {max(lat_lon, key=lambda x:x[0])}\")\n\nlat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=1080)\nprint(f\"Max Latitude (within 0.3 degree): {max(lat_lon, key=lambda x:x[0])}\")\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#maximum-latitude-on-a-great-circle-path","position":11},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Plot Maximum","lvl2":"Maximum Latitude on a Great Circle Path"},"type":"lvl3","url":"/notebooks/tutorials/parallels-max-min#plot-maximum","position":12},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Plot Maximum","lvl2":"Maximum Latitude on a Great Circle Path"},"content":"\n\ndef plot_coordinate_max_min(great_circle_pts=None,\n                            max_coord=None, min_coord=None,\n                            title=None):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    lon_west, lon_east, lat_south, lat_north = -180, 180, -90, 90\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n    \n    # Plot Great Circle Latitude/Longitude Location\n    longitudes = [x[1] for x in great_circle_pts] # longitude\n    latitudes = [x[0] for x in great_circle_pts] # latitude\n    plt.plot(longitudes, latitudes)\n\n    # Overly Max/Min Coordinates\n    if max_coord is not None:\n        plt.scatter([max_coord[1]], [max_coord[0]], s=100, c=\"red\")\n    if min_coord is not None:\n        plt.scatter([min_coord[1]], [min_coord[0]], s=100, c=\"green\")\n    \n    # Setup Axis Limits and Title/Labels\n    plt.title(title)\n    plt.show()\n\ngc_lat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=360)\nmax_lat_lon = max(gc_lat_lon, key=lambda x:x[0])\nplot_coordinate_max_min(great_circle_pts=gc_lat_lon,\n                            max_coord=max_lat_lon,\n                            title=f\"Max Latitude located at {max_lat_lon}\")\n\ngc_lat_lon = generate_latitude_along_gc(\"boulder\", \"houston\", number_of_lon_pts=360)\nmax_lat_lon = max(gc_lat_lon, key=lambda x:x[0])\nplot_coordinate_max_min(great_circle_pts=gc_lat_lon,\n                            max_coord=max_lat_lon,\n                            title=f\"Max Latitude located at {max_lat_lon}\")\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#plot-maximum","position":13},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Maximumn Latitude from Clairaut’s Formula","lvl2":"Maximum Latitude on a Great Circle Path"},"type":"lvl3","url":"/notebooks/tutorials/parallels-max-min#maximumn-latitude-from-clairauts-formula","position":14},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Maximumn Latitude from Clairaut’s Formula","lvl2":"Maximum Latitude on a Great Circle Path"},"content":"Clairaut’s Formula (Clairaut’s equation or Clairaut’s relation) is a differential equation which defines the relationship between the latitude, φ, and the true course (bearing, θ) where:sin(θ) * cos(φ) = \\text{constant}\n\nSo, for any two points (A and B) along the great circle:sin(θA) * cos(φA) = sin(θB) * cos(φB)\n\nSo, to solve for the maximum latitude the true course should be when 90 and 270 degrees on the unit sphere where for any bearing/latitude along the great circle:\\text{max latitude} = acos(|sin(θ) * cos(φ)|)\n\nFor the purpose of this example, we will use pyproj geodesic to determine the bearing based on a great circle arc, but consult previous sections if you want to determine bearing mathetically based on the unit sphere instead of the ellipsoid.\n\nImportant Note\n\nClairaut’s Formula works from unit sphere, and as a result, is subject to errors (about 3%, about +/- 11 degrees).\n\nEd Williams: Clairaut’s Formula\n\ndef clairaut_formula_max(start_point=None, end_point=None):\n    geodesic = Geod(ellps=\"WGS84\")\n    fwd_bearing, _, _ =  geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                      location_df.loc[start_point, \"latitude\"],\n                                      location_df.loc[end_point, \"longitude\"],\n                                      location_df.loc[end_point, \"latitude\"])\n    # Clairaut\n    start_lat = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    max_lat = np.arccos(np.abs(np.sin(fwd_bearing) * np.cos(start_lat)))\n    return np.rad2deg(max_lat)\n\nmax_lat = clairaut_formula_max(\"boulder\", \"boston\")\nprint(f\"Max latitude from Boulder to Boston: {max_lat}\")\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#maximumn-latitude-from-clairauts-formula","position":15},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Minimum Latitude on a Great Circle Path"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#minimum-latitude-on-a-great-circle-path","position":16},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Minimum Latitude on a Great Circle Path"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#minimum-latitude-on-a-great-circle-path","position":17},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Antipodal Point of Max (TODO)","lvl2":"Minimum Latitude on a Great Circle Path"},"type":"lvl3","url":"/notebooks/tutorials/parallels-max-min#antipodal-point-of-max-todo","position":18},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Antipodal Point of Max (TODO)","lvl2":"Minimum Latitude on a Great Circle Path"},"content":"\n\ndef antipodal(latitude=None, longitude=None):\n    anti_lat = -1 * latitude\n    if longitude > 0:\n        anti_lon = longitude - 180\n    else:\n        anti_lon = longitude + 180\n    return (anti_lat, anti_lon)\n\nLike finding maximum from a list of great circle path, the smallest latitude can be found by analysing the list for the smallest latitude point.\n\ngc_lat_lon = generate_latitude_along_gc(\"boulder\", \"houston\", number_of_lon_pts=360)\nmax_lat_lon = max(gc_lat_lon, key=lambda x:x[0])\nprint(max_lat_lon)\nantipodal(max_lat_lon[0], max_lat_lon[1])\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#antipodal-point-of-max-todo","position":19},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Minimum Latitude along Great Circle Path","lvl2":"Minimum Latitude on a Great Circle Path"},"type":"lvl3","url":"/notebooks/tutorials/parallels-max-min#minimum-latitude-along-great-circle-path","position":20},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Minimum Latitude along Great Circle Path","lvl2":"Minimum Latitude on a Great Circle Path"},"content":"\n\nlat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=360)\nprint(f\"Min Latitude (within 1 degree): {min(lat_lon, key=lambda x:x[0])}\")\n\nlat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=720)\nprint(f\"Min Latitude (within 0.5 degree): {min(lat_lon, key=lambda x:x[0])}\")\n\nlat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=1080)\nprint(f\"Min Latitude (within 0.3 degree): {min(lat_lon, key=lambda x:x[0])}\")\n\ngc_lat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=360)\nmin_lat_lon = min(gc_lat_lon, key=lambda x:x[0])\nplot_coordinate_max_min(great_circle_pts=gc_lat_lon,\n                            min_coord=min_lat_lon,\n                            title=f\"Min Latitude located at {min_lat_lon}\")\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#minimum-latitude-along-great-circle-path","position":21},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Maximumn Latitude from Clairaut’s Formula","lvl2":"Minimum Latitude on a Great Circle Path"},"type":"lvl3","url":"/notebooks/tutorials/parallels-max-min#maximumn-latitude-from-clairauts-formula-1","position":22},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Maximumn Latitude from Clairaut’s Formula","lvl2":"Minimum Latitude on a Great Circle Path"},"content":"To solve for the minimum, the true course should be when 0 and 180 degrees on the unit sphere where for any bearing/latitude along the great circle:\\text{min latitude} = asin(|sin(θ) * cos(φ)|)\n\nThe southernmost point is the antipode to the northernmost (max) latitude.\n\ndef clairaut_formula_min(start_point=None, end_point=None):\n    geodesic = Geod(ellps=\"WGS84\")\n    fwd_bearing, _, _ =  geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                      location_df.loc[start_point, \"latitude\"],\n                                      location_df.loc[end_point, \"longitude\"],\n                                      location_df.loc[end_point, \"latitude\"])\n    # Clairaut Formula\n    start_lat = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    min_lat = np.arcsin(np.abs(np.cos(fwd_bearing) * np.sin(start_lat)))\n    return np.rad2deg(min_lat)\n\nmin_lat = clairaut_formula_min(\"boulder\", \"boston\")\nprint(f\"Min latitude along great circle path from Boulder to Boston: {min_lat}\")\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#maximumn-latitude-from-clairauts-formula-1","position":23},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Determine when great circle path cross parallels (TODO)"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#determine-when-great-circle-path-cross-parallels-todo","position":24},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Determine when great circle path cross parallels (TODO)"},"content":"Determine the longitude when a great circle crosses a given latitude parrellel.\n\n\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#determine-when-great-circle-path-cross-parallels-todo","position":25},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#summary","position":26},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Summary"},"content":"Determine the coordinates when a great circle path crosses a specific parallel as well as the maximumn and minimum latitude coordinates.","type":"content","url":"/notebooks/tutorials/parallels-max-min#summary","position":27},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/tutorials/parallels-max-min#whats-next","position":28},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"What’s next?","lvl2":"Summary"},"content":"Intersections of Great Circles.\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#whats-next","position":29},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#resources-and-references","position":30},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Resources and references"},"content":"\n\nAviation Formulary V1.47\n\nMoveable Type Script","type":"content","url":"/notebooks/tutorials/parallels-max-min#resources-and-references","position":31},{"hierarchy":{"lvl1":"Intersections of Great Circles"},"type":"lvl1","url":"/notebooks/tutorials/path-intersection","position":0},{"hierarchy":{"lvl1":"Intersections of Great Circles"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/path-intersection","position":1},{"hierarchy":{"lvl1":"Intersections of Great Circles"},"type":"lvl1","url":"/notebooks/tutorials/path-intersection#intersections-of-great-circles","position":2},{"hierarchy":{"lvl1":"Intersections of Great Circles"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#intersections-of-great-circles","position":3},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#overview","position":4},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Overview"},"content":"A great circle path crosses the entire planet and any two valid great circle paths will always intersect.\n\nFind the intersection of two great circle paths (always exists)\n\nFind the intersection of two great circle arcs (if it exists) (TODO)\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#overview","position":5},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#prerequisites","position":6},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 40 minutes\n\n\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#prerequisites","position":7},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#imports","position":8},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Imports"},"content":"Import Packages\n\nSetup location dataframe with coordinates\n\nimport pandas as pd       # reading in data for location information from text file\nimport numpy as np        # working with arrays, vectors, cross/dot products, and radians\n\nfrom pyproj import Geod   # working with the Earth as an ellipsod (WGS-84)\nimport geopy.distance     # working with the Earth as an ellipsod\n\nimport matplotlib.pyplot as plt                        # plotting a graph\nfrom cartopy import crs as ccrs, feature as cfeature   # plotting a world map\n\n# Get all Coordinates for Locations\nlocation_df = pd.read_csv(\"../location_full_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df.head()\n\nlocation_df.index = location_df[\"name\"]\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#imports","position":9},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Find the intersection of two great circle paths"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#find-the-intersection-of-two-great-circle-paths","position":10},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Find the intersection of two great circle paths"},"content":"The intersection of two great circle paths always exists at two positions on the globe if both paths are valid great circle paths (not meridians).\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#find-the-intersection-of-two-great-circle-paths","position":11},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl3":"Math of intersection","lvl2":"Find the intersection of two great circle paths"},"type":"lvl3","url":"/notebooks/tutorials/path-intersection#math-of-intersection","position":12},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl3":"Math of intersection","lvl2":"Find the intersection of two great circle paths"},"content":"TODO\n\n# Generate Latitude Coordinates based on Longitude Coordinates\ndef generate_latitude_along_gc(start_point=None, end_point=None, number_of_lon_pts=360):\n    lon1 = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    lat1 = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lon2 = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n    lat2 = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n\n    # Verify not meridian (longitude passes through the poles)\n    if np.sin(lon1 - lon2) == 0:\n        print(\"Invalid inputs: start/end points are meridians\")\n        # plotting meridians at 0 longitude through all latitudes\n        meridian_lat = np.arange(-90, 90, 180/len(longitude_lst)) # split in n number\n        meridians = []\n        for lat in meridian_lat:\n            meridians.append((lat, 0))\n        return meridians\n\n    # verify not anitpodal (diametrically opposite, points)\n    if lat1 + lat2 == 0 and abs(lon1-lon2) == np.pi:\n        print(\"Invalid inputs: start/end points are antipodal\")\n        return []\n\n    # note: can be expanded to handle input of np arrays by filter out antipodal/merdiain points\n\n    # generate n total number of longitude points along the great circle\n    # https://github.com/rspatial/geosphere/blob/master/R/greatCircle.R#L18C3-L18C7\n    gc_lon_lst = []\n    for lon in range(1, number_of_lon_pts+1):\n        new_lon = (lon  * (360/number_of_lon_pts) - 180)\n        gc_lon_lst.append(np.deg2rad(new_lon))\n\n    # Intermediate points on a great circle: https://edwilliams.org/avform147.htm\"\n    gc_lat_lon = []\n    for gc_lon in gc_lon_lst:\n        num = np.sin(lat1)*np.cos(lat2)*np.sin(gc_lon-lon2)-np.sin(lat2)*np.cos(lat1)*np.sin(gc_lon-lon1)\n        den = np.cos(lat1)*np.cos(lat2)*np.sin(lon1-lon2)\n        new_lat = np.arctan(num/den)\n        gc_lat_lon.append((np.rad2deg(new_lat), np.rad2deg(gc_lon)))\n    return gc_lat_lon\n\nlat_lon_pts = generate_latitude_along_gc(\"boulder\", \"boston\", 360)\n\ndef intersection_of_gc(start_gc1=None, end_gc1=None,\n                      start_gc2=None, end_gc2=None):\n    # get normal of planes containing great circles\n\n    # cross product of vectors\n    normal_one = np.cross([location_df.loc[start_gc1, \"cart_x\"],\n                           location_df.loc[start_gc1, \"cart_y\"],\n                           location_df.loc[start_gc1, \"cart_z\"]],\n                          [location_df.loc[end_gc1, \"cart_x\"],\n                           location_df.loc[end_gc1, \"cart_y\"],\n                           location_df.loc[end_gc1, \"cart_z\"]])\n    normal_two = np.cross([location_df.loc[start_gc2, \"cart_x\"],\n                           location_df.loc[start_gc2, \"cart_y\"],\n                           location_df.loc[start_gc2, \"cart_z\"]],\n                          [location_df.loc[end_gc2, \"cart_x\"],\n                           location_df.loc[end_gc2, \"cart_y\"],\n                           location_df.loc[end_gc2, \"cart_z\"]])\n    # intersection of planes, normal to the poles of each plane\n    line_of_intersection = np.cross(normal_one, normal_two)\n    # intersection points (one on each side of the earth)\n    x1 = line_of_intersection /  np.sqrt(line_of_intersection[0]**2 + line_of_intersection[1]**2 + line_of_intersection[2]**2) \n    x2 = -x1\n    lat1 = np.rad2deg(np.arctan2(x1[2], np.sqrt(pow(x1[0],2)+pow(x1[1],2))))\n    lon1 = np.rad2deg(np.arctan2(x1[1], x1[0]))\n    lat2 = np.rad2deg(np.arctan2(x2[2], np.sqrt(pow(x2[0],2)+pow(x2[1],2))))\n    lon2 = np.rad2deg(np.arctan2(x2[1], x2[0]))\n    return [(lat1, lon1), (lat2, lon2)]\n\nintersect_pts = intersection_of_gc(\"boulder\", \"boston\", \"greenwich\", \"cairo\")\nintersect_pts\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#math-of-intersection","position":13},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl3":"Plot Intersections with Great Circle Paths","lvl2":"Find the intersection of two great circle paths"},"type":"lvl3","url":"/notebooks/tutorials/path-intersection#plot-intersections-with-great-circle-paths","position":14},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl3":"Plot Intersections with Great Circle Paths","lvl2":"Find the intersection of two great circle paths"},"content":"\n\ndef interpolate_points_along_gc(start_point=None, end_point=None,\n                                distance_between_points_meter=0): \n    geodesic = Geod(ellps=\"WGS84\")\n    \n    lat_start = location_df.loc[start_point, \"latitude\"]\n    lon_start = location_df.loc[start_point, \"longitude\"]\n    lat_end = location_df.loc[end_point, \"latitude\"]\n    lon_end = location_df.loc[end_point, \"longitude\"]\n\n    lat_lon_points = [(lat_start, lon_start)]\n    \n    # move to next point when distance between points is less than the equal distance\n    move_to_next_point = True\n    while(move_to_next_point):\n        forward_bearing, _, distance_meters = geodesic.inv(lon_start,\n                                                            lat_start, \n                                                            lon_end,\n                                                            lat_end)\n        if distance_meters < distance_between_points_meter:\n            # ends before overshooting\n            move_to_next_point = False\n        else:\n            start_point = geopy.Point(lat_start, lon_start)\n            distance_to_move = geopy.distance.distance(\n                            kilometers=distance_between_points_meter /\n                            1000)  # distance to move towards the next point\n            final_position = distance_to_move.destination(\n                            start_point, bearing=forward_bearing)\n            lat_lon_points.append((final_position.latitude, final_position.longitude))\n            # new starting position is newly found end position\n            lon_start, lat_start = final_position.longitude, final_position.latitude\n    lat_lon_points.append((lat_end, lon_end))\n    return lat_lon_points\n\ndef arc_points(start_point=None, end_point=None,\n               n_total_points=10):\n    start_lat = location_df.loc[start_point, \"latitude\"]\n    start_lon = location_df.loc[start_point, \"longitude\"]\n    end_lat = location_df.loc[end_point, \"latitude\"]\n    end_lon = location_df.loc[end_point, \"longitude\"]\n\n    geodesic = Geod(ellps=\"WGS84\")\n\n    _, _, distance_meter =  geodesic.inv(start_lon,\n                                        start_lat,\n                                        end_lon,\n                                        end_lat)\n        \n    distance_between_points_meter = distance_meter / (n_total_points + 1)\n\n    \n    points_along_arc = interpolate_points_along_gc(start_point, end_point,\n                                              distance_between_points_meter)\n    return points_along_arc\n\ndef plot_gc_with_intersection(start_gc1=None, end_gc1=None,\n                             start_gc2=None, end_gc2=None,\n                             lon_west=-180, lon_east=180,\n                             lat_south=-90, lat_north=90):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n\n    # Plot Great Circle Path\n    gc_one_lat_pts = generate_latitude_along_gc(start_gc1, end_gc1)\n    longitudes = [x[1] for x in gc_one_lat_pts] # longitude\n    latitudes = [x[0] for x in gc_one_lat_pts] # latitude\n    plt.plot(longitudes, latitudes)\n    gc_two_lat_pts = generate_latitude_along_gc(start_gc2, end_gc2)\n    longitudes = [x[1] for x in gc_two_lat_pts] # longitude\n    latitudes = [x[0] for x in gc_two_lat_pts] # latitude\n    plt.plot(longitudes, latitudes)\n\n    # Plot intersection point\n    intersection_point = intersection_of_gc(start_gc1, end_gc1,\n                                            start_gc2, end_gc2)\n    longitudes = [x[1] for x in intersection_point] # longitude\n    latitudes = [x[0] for x in intersection_point] # latitude\n    plt.scatter(longitudes, latitudes, s=200, c=\"purple\", label=\"intersection\")\n\n    # Plot Great Circle Arc\n    gc_one_arc_pts = arc_points(start_gc1, end_gc1)\n    longitudes = [x[1] for x in gc_one_arc_pts] # longitude\n    latitudes = [x[0] for x in gc_one_arc_pts] # latitude\n    plt.plot(longitudes, latitudes, c=\"pink\", label=\"GC 1\")\n    plt.scatter(longitudes[0], latitudes[0], s=100, c=\"green\", label=\"Arc Start\")\n    plt.scatter(longitudes[-1], latitudes[-1],s=100, c=\"red\", label=\"Arc End\")\n\n    gc_two_arc_pts = arc_points(start_gc2, end_gc2)\n    longitudes = [x[1] for x in gc_two_arc_pts] # longitude\n    latitudes = [x[0] for x in gc_two_arc_pts] # latitude\n    plt.plot(longitudes, latitudes, c=\"cyan\", label=\"GC 2\")\n    plt.scatter(longitudes[0], latitudes[0],s=100, c=\"green\")\n    plt.scatter(longitudes[-1], latitudes[-1],s=100, c=\"red\")\n\n    plt.legend(loc=\"lower left\")\n    plt.title(f\"Intersection Point = {intersection_point}\")\n    plt.show()\n\nplot_gc_with_intersection(\"boulder\", \"boston\", \"greenwich\", \"cairo\")\n\nplot_gc_with_intersection(\"arecibo\", \"zambezi\", \"johannesburg\", \"reykjavík\")\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#plot-intersections-with-great-circle-paths","position":15},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Find the intersection of two great circle arcs (TODO)"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#find-the-intersection-of-two-great-circle-arcs-todo","position":16},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Find the intersection of two great circle arcs (TODO)"},"content":"The intersection of two great circle paths always exists at two positions on the globem but intersections do not always exists along the great circle arcs.\n\n\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#find-the-intersection-of-two-great-circle-arcs-todo","position":17},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#summary","position":18},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Summary"},"content":"","type":"content","url":"/notebooks/tutorials/path-intersection#summary","position":19},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/tutorials/path-intersection#whats-next","position":20},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl3":"What’s next?","lvl2":"Summary"},"content":"Angles and Great Circles\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#whats-next","position":21},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#resources-and-references","position":22},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Resources and references"},"content":"\n\nAviation Formulary V1.47\n\nMoveable Type Script","type":"content","url":"/notebooks/tutorials/path-intersection#resources-and-references","position":23},{"hierarchy":{"lvl1":"Angles and Great Circles"},"type":"lvl1","url":"/notebooks/tutorials/angles","position":0},{"hierarchy":{"lvl1":"Angles and Great Circles"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/angles","position":1},{"hierarchy":{"lvl1":"Angles and Great Circles"},"type":"lvl1","url":"/notebooks/tutorials/angles#angles-and-great-circles","position":2},{"hierarchy":{"lvl1":"Angles and Great Circles"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/angles#angles-and-great-circles","position":3},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/angles#overview","position":4},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Overview"},"content":"Angles are formed by the intersection of great circle paths.\n\nCalculate the acute and obtuse angle of two Great Circle paths\n\nCalculate the Directed Angle of two Great Circle paths based on an intersection point\n\nWorking with Spherical Triangles formed by great circle arcs (TODO)\n\n","type":"content","url":"/notebooks/tutorials/angles#overview","position":5},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/angles#prerequisites","position":6},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 40 minutes\n\n\n\n","type":"content","url":"/notebooks/tutorials/angles#prerequisites","position":7},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/angles#imports","position":8},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Imports"},"content":"Import Packages\n\nSetup location dataframe with coordinates\n\nimport pandas as pd       # reading in data for location information from text file\nimport numpy as np        # working with arrays, vectors, cross/dot products, and radians\n\nfrom pyproj import Geod   # working with the Earth as an ellipsod (WGS-84)\nimport geopy.distance     # working with the Earth as an ellipsod\n\nimport matplotlib.pyplot as plt                        # plotting a graph\nfrom cartopy import crs as ccrs, feature as cfeature   # plotting a world map\n\n# Get all Coordinates for Locations\nlocation_df = pd.read_csv(\"../location_full_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df.head()\n\nlocation_df.index = location_df[\"name\"]\n\nlocation_df.loc[\"boulder\", \"latitude\"]\n\n","type":"content","url":"/notebooks/tutorials/angles#imports","position":9},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Calculate the acute and obtuse angle of two great circle paths"},"type":"lvl2","url":"/notebooks/tutorials/angles#calculate-the-acute-and-obtuse-angle-of-two-great-circle-paths","position":10},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Calculate the acute and obtuse angle of two great circle paths"},"content":"The acute and obtuse angle formed by two great circle paths and an intersection point.\n\ndef angle_between_arcs(start_gc1=None, end_gc1=None,\n                       start_gc2=None, end_gc2=None):\n    # get normal of planes containing great circles\n    normal_one = np.cross([location_df.loc[start_gc1, \"cart_x\"],\n                           location_df.loc[start_gc1, \"cart_y\"],\n                           location_df.loc[start_gc1, \"cart_z\"]],\n                          [location_df.loc[end_gc1, \"cart_x\"],\n                           location_df.loc[end_gc1, \"cart_y\"],\n                           location_df.loc[end_gc1,\"cart_z\"]])\n    normal_two = np.cross([location_df.loc[start_gc2, \"cart_x\"],\n                           location_df.loc[start_gc2, \"cart_y\"],\n                           location_df.loc[start_gc2, \"cart_z\"]],\n                          [location_df.loc[end_gc2, \"cart_x\"],\n                           location_df.loc[end_gc2, \"cart_y\"],\n                           location_df.loc[end_gc2,\"cart_z\"]])\n    # dot product to obtain the angle between the normal planes\n    angle_between_planes = np.dot(normal_one, normal_two)\n    # divide by the magnitude of the vectors, inverse of cos to find angle\n    angle = np.arccos(np.dot(normal_one, normal_two) / \n                    (np.linalg.norm(normal_one) * np.linalg.norm(normal_two)))\n    obtuse_acute_angle = (np.rad2deg(angle), ((360-(2*np.rad2deg(angle)))/2))\n    obtuse_angle = np.max(obtuse_acute_angle)\n    print(f\"Acute Angle  = {np.min(obtuse_acute_angle)} degrees\")\n    print(f\"Obtuse Angle = {np.max(obtuse_acute_angle)} degrees\")\n    return obtuse_acute_angle\n\nangle_between_arcs(\"boulder\", \"boston\", \"johannesburg\", \"reykjavík\")\n\n","type":"content","url":"/notebooks/tutorials/angles#calculate-the-acute-and-obtuse-angle-of-two-great-circle-paths","position":11},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Calculate the Directed Angle of two Great Circle paths based on an intersection point"},"type":"lvl2","url":"/notebooks/tutorials/angles#calculate-the-directed-angle-of-two-great-circle-paths-based-on-an-intersection-point","position":12},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Calculate the Directed Angle of two Great Circle paths based on an intersection point"},"content":"Calculate the directed angle of two great circle paths based on an intersection point.","type":"content","url":"/notebooks/tutorials/angles#calculate-the-directed-angle-of-two-great-circle-paths-based-on-an-intersection-point","position":13},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Overview of Directed Angles","lvl2":"Calculate the Directed Angle of two Great Circle paths based on an intersection point"},"type":"lvl3","url":"/notebooks/tutorials/angles#overview-of-directed-angles","position":14},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Overview of Directed Angles","lvl2":"Calculate the Directed Angle of two Great Circle paths based on an intersection point"},"content":"TODO\n\nFinds the directed angle between two great circles defined by three points: A, B, C where A->B and A->C are arcs on the great circle (where A is where the arcs intersect\n\nReturned angle is positive if C is to the left of the great circles A->B\n\nReturned angle is negative if C is to the right of the great circles A->B\n\nDirected angle is in the standard position if it satistfies two conditions:\n\nIts vertex is the origin of rectangular coordinates system\nIts initial side lies on the positive direction of the x-axis\n\nThe directed angle resulting from an anticlockwise rotation has a positive measure\n\nThe directed angle resulting from a clockwise rotation has a negative measure\n\ndef directed_angle(b_coords=None, c_coords=None, a_coords=None):\n    # determine cartesian_coordinates from intersect points\n    earth_radius = 6378137  # meters\n    latitude = np.deg2rad(a_coords[0])\n    longitude = np.deg2rad(a_coords[1])\n    cart_x = earth_radius * np.cos(latitude) * np.cos(longitude)\n    cart_y = earth_radius * np.cos(latitude) * np.sin(longitude)\n    cart_z = earth_radius * np.sin(latitude)\n\n    # get normal of planes containing great circles\n    normal_one = np.cross([cart_x,\n                           cart_y,\n                           cart_z],\n                          [location_df.loc[b_coords, \"cart_x\"],\n                           location_df.loc[b_coords, \"cart_y\"],\n                           location_df.loc[b_coords, \"cart_z\"]])\n    normal_two = np.cross([cart_x,\n                           cart_y,\n                           cart_z],\n                          [location_df.loc[c_coords, \"cart_x\"],\n                           location_df.loc[c_coords, \"cart_y\"],\n                           location_df.loc[c_coords, \"cart_z\"]])\n    # dot product to obtain the angle between the normal planes\n    angle_between_planes = np.dot(normal_one, normal_two)\n    # divide by the magnitude of the vectors, inverse of cos to find angle\n    angle = np.arccos(np.dot(normal_one, normal_two) / \n                    (np.linalg.norm(normal_one) * np.linalg.norm(normal_two)))\n    angle = np.rad2deg(angle)\n\n    # take the cross product of two vectors A->B and A->C\n    v_ab = np.array([[cart_x,\n                    cart_y,\n                    cart_z],\n                    [location_df.loc[b_coords, \"cart_x\"],\n                     location_df.loc[b_coords, \"cart_y\"],\n                     location_df.loc[b_coords, \"cart_z\"]]])\n    v_ac = np.array([[cart_x,\n                    cart_y,\n                    cart_z],\n                    [location_df.loc[c_coords, \"cart_x\"],\n                     location_df.loc[c_coords, \"cart_y\"],\n                     location_df.loc[c_coords, \"cart_z\"]]])\n\n    cross_prod = np.cross(v_ab, v_ac)\n    # inverse of the sign of the cross product\n    sign_angle = -1*np.sign(cross_prod[1][-1]) * angle\n    return sign_angle\n\n","type":"content","url":"/notebooks/tutorials/angles#overview-of-directed-angles","position":15},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Calculate Intersection Point Between Two Great Circle Paths","lvl2":"Calculate the Directed Angle of two Great Circle paths based on an intersection point"},"type":"lvl3","url":"/notebooks/tutorials/angles#calculate-intersection-point-between-two-great-circle-paths","position":16},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Calculate Intersection Point Between Two Great Circle Paths","lvl2":"Calculate the Directed Angle of two Great Circle paths based on an intersection point"},"content":"See previous section for more details\n\ndef intersection_of_gc(start_gc1=None, end_gc1=None,\n                      start_gc2=None, end_gc2=None):\n    # get normal of planes containing great circles\n\n    # cross product of vectors\n    normal_one = np.cross([location_df.loc[start_gc1, \"cart_x\"],\n                           location_df.loc[start_gc1, \"cart_y\"],\n                           location_df.loc[start_gc1, \"cart_z\"]],\n                          [location_df.loc[end_gc1, \"cart_x\"],\n                           location_df.loc[end_gc1, \"cart_y\"],\n                           location_df.loc[end_gc1, \"cart_z\"]])\n    normal_two = np.cross([location_df.loc[start_gc2, \"cart_x\"],\n                           location_df.loc[start_gc2, \"cart_y\"],\n                           location_df.loc[start_gc2, \"cart_z\"]],\n                          [location_df.loc[end_gc2, \"cart_x\"],\n                           location_df.loc[end_gc2, \"cart_y\"],\n                           location_df.loc[end_gc2, \"cart_z\"]])\n    # intersection of planes, normal to the poles of each plane\n    line_of_intersection = np.cross(normal_one, normal_two)\n    # intersection points (one on each side of the earth)\n    x1 = line_of_intersection /  np.sqrt(line_of_intersection[0]**2 + line_of_intersection[1]**2 + line_of_intersection[2]**2) \n    x2 = -x1\n    lat1 = np.rad2deg(np.arctan2(x1[2], np.sqrt(pow(x1[0],2)+pow(x1[1],2))))\n    lon1 = np.rad2deg(np.arctan2(x1[1], x1[0]))\n    lat2 = np.rad2deg(np.arctan2(x2[2], np.sqrt(pow(x2[0],2)+pow(x2[1],2))))\n    lon2 = np.rad2deg(np.arctan2(x2[1], x2[0]))\n    return [(lat1, lon1), (lat2, lon2)]\n\nintersect_pts = intersection_of_gc(\"boulder\", \"boston\", \"johannesburg\", \"reykjavík\")\nintersect_pts\n\n# Arcs defined as A->B and A->C where A is the intersection\ndirected_angle(a_coords=intersect_pts[0],\n               b_coords=\"boulder\",\n               c_coords=\"reykjavík\")\n\n# Arcs defined as A->B and A->C where A is the intersection\ndirected_angle(a_coords=intersect_pts[-1],\n               b_coords=\"boulder\",\n               c_coords=\"reykjavík\")\n\n","type":"content","url":"/notebooks/tutorials/angles#calculate-intersection-point-between-two-great-circle-paths","position":17},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Plot Directed Angle","lvl2":"Calculate the Directed Angle of two Great Circle paths based on an intersection point"},"type":"lvl3","url":"/notebooks/tutorials/angles#plot-directed-angle","position":18},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Plot Directed Angle","lvl2":"Calculate the Directed Angle of two Great Circle paths based on an intersection point"},"content":"Clockwise and Counterclockwise\n\n# See previous section for more information\n\n# Generate Latitude Coordinates based on Longitude Coordinates\ndef generate_latitude_along_gc(start_lat=None, start_lon=None,\n                               end_lat=None, end_lon=None,\n                               number_of_lon_pts=360):\n    lon1 = np.deg2rad(start_lon)\n    lat1 = np.deg2rad(start_lat)\n    lon2 = np.deg2rad(end_lon)\n    lat2 = np.deg2rad(end_lat)\n\n    # Verify not meridian (longitude passes through the poles)\n    if np.sin(lon1 - lon2) == 0:\n        print(\"Invalid inputs: start/end points are meridians\")\n        # plotting meridians at 0 longitude through all latitudes\n        meridian_lat = np.arange(-90, 90, 180/len(longitude_lst)) # split in n number\n        meridians = []\n        for lat in meridian_lat:\n            meridians.append((lat, 0))\n        return meridians\n\n    # verify not anitpodal (diametrically opposite, points)\n    if lat1 + lat2 == 0 and abs(lon1-lon2) == np.pi:\n        print(\"Invalid inputs: start/end points are antipodal\")\n        return []\n\n    # note: can be expanded to handle input of np arrays by filter out antipodal/merdiain points\n\n    # generate n total number of longitude points along the great circle\n    # https://github.com/rspatial/geosphere/blob/master/R/greatCircle.R#L18C3-L18C7\n    gc_lon_lst = []\n    for lon in range(1, number_of_lon_pts+1):\n        new_lon = (lon  * (360/number_of_lon_pts) - 180)\n        gc_lon_lst.append(np.deg2rad(new_lon))\n\n    # Intermediate points on a great circle: https://edwilliams.org/avform147.htm\"\n    gc_lat_lon = []\n    for gc_lon in gc_lon_lst:\n        num = np.sin(lat1)*np.cos(lat2)*np.sin(gc_lon-lon2)-np.sin(lat2)*np.cos(lat1)*np.sin(gc_lon-lon1)\n        den = np.cos(lat1)*np.cos(lat2)*np.sin(lon1-lon2)\n        new_lat = np.arctan(num/den)\n        gc_lat_lon.append((np.rad2deg(new_lat), np.rad2deg(gc_lon)))\n    return gc_lat_lon\n\ndef interpolate_points_along_gc(lat_start=None, lon_start=None,\n                                lat_end=None, lon_end=None,\n                                distance_between_points_meter=0): \n    geodesic = Geod(ellps=\"WGS84\")\n    \n    lat_lon_points = [(lat_start, lon_start)]\n    \n    # move to next point when distance between points is less than the equal distance\n    move_to_next_point = True\n    while(move_to_next_point):\n        forward_bearing, _, distance_meters = geodesic.inv(lon_start,\n                                                            lat_start, \n                                                            lon_end,\n                                                            lat_end)\n        if distance_meters < distance_between_points_meter:\n            # ends before overshooting\n            move_to_next_point = False\n        else:\n            start_point = geopy.Point(lat_start, lon_start)\n            distance_to_move = geopy.distance.distance(\n                            kilometers=distance_between_points_meter /\n                            1000)  # distance to move towards the next point\n            final_position = distance_to_move.destination(\n                            start_point, bearing=forward_bearing)\n            lat_lon_points.append((final_position.latitude, final_position.longitude))\n            # new starting position is newly found end position\n            lon_start, lat_start = final_position.longitude, final_position.latitude\n    lat_lon_points.append((lat_end, lon_end))\n    return lat_lon_points\n\ndef arc_points(start_lat=None, start_lon=None,\n               end_lat=None, end_lon=None,\n               n_total_points=10):\n\n    geodesic = Geod(ellps=\"WGS84\")\n\n    _, _, distance_meter =  geodesic.inv(start_lon,\n                                        start_lat,\n                                        end_lon,\n                                        end_lat)\n        \n    distance_between_points_meter = distance_meter / (n_total_points + 1)\n\n    \n    points_along_arc = interpolate_points_along_gc(start_lat, start_lon,\n                                                   end_lat, end_lon,\n                                                    distance_between_points_meter)\n    return points_along_arc\n\ndef plot_gc_directed_angle(a_coords=None, b_coords=None,c_coords=None,\n                           angle=None,\n                           lon_west=-180, lon_east=180,\n                           lat_south=-90, lat_north=90):\n    # A = intersect point\n    # A->B and A->C where C is the angle to determine sign\n\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n\n    # Plot Great Circle Path\n    gc_one_lat_pts = generate_latitude_along_gc(start_lat=a_coords[0],\n                                                start_lon=a_coords[1],\n                                                end_lat=location_df.loc[b_coords, \"latitude\"],\n                                                end_lon=location_df.loc[b_coords, \"longitude\"])\n    longitudes = [x[1] for x in gc_one_lat_pts] # longitude\n    latitudes = [x[0] for x in gc_one_lat_pts] # latitude\n    plt.plot(longitudes, latitudes)\n    gc_two_lat_pts =  generate_latitude_along_gc(start_lat=a_coords[0],\n                                                start_lon=a_coords[1],\n                                                end_lat=location_df.loc[c_coords, \"latitude\"],\n                                                end_lon=location_df.loc[c_coords, \"longitude\"])\n    longitudes = [x[1] for x in gc_two_lat_pts] # longitude\n    latitudes = [x[0] for x in gc_two_lat_pts] # latitude\n    plt.plot(longitudes, latitudes)\n\n    # Plot Great Circle Arc\n    gc_one_arc_pts = arc_points(start_lat=a_coords[0],\n                               start_lon=a_coords[1],\n                               end_lat=location_df.loc[b_coords, \"latitude\"],\n                               end_lon=location_df.loc[b_coords, \"longitude\"])\n    longitudes = [x[1] for x in gc_one_arc_pts] # longitude\n    latitudes = [x[0] for x in gc_one_arc_pts] # latitude\n    plt.plot(longitudes, latitudes, c=\"pink\")\n    gc_two_arc_pts = arc_points(start_lat=a_coords[0],\n                               start_lon=a_coords[1],\n                               end_lat=location_df.loc[c_coords, \"latitude\"],\n                               end_lon=location_df.loc[c_coords, \"longitude\"])\n    longitudes = [x[1] for x in gc_two_arc_pts] # longitude\n    latitudes = [x[0] for x in gc_two_arc_pts] # latitude\n    plt.plot(longitudes, latitudes, c=\"green\")\n\n    # plot A, B, C points in different colors\n    fz = 30\n    offset = 3\n    plt.scatter(a_coords[1], a_coords[0], s=100, c=\"red\", label=\"A\")\n    ax.annotate(\"A\", (a_coords[1]+offset, a_coords[0]+offset), fontsize=fz)\n    plt.scatter(location_df.loc[b_coords, \"longitude\"],\n               location_df.loc[b_coords, \"latitude\"],\n                s=100, c=\"blue\", label=\"B\")\n    ax.annotate(\"B\", (location_df.loc[b_coords, \"longitude\"]-(4*offset),\n                      location_df.loc[b_coords, \"latitude\"]-offset),\n                        fontsize=fz)\n    plt.scatter(location_df.loc[c_coords, \"longitude\"],\n                location_df.loc[c_coords, \"latitude\"], \n                s=100, c=\"cyan\", label=\"C\")\n    ax.annotate(\"C\", (location_df.loc[c_coords, \"longitude\"]+offset,\n                      location_df.loc[c_coords, \"latitude\"]+offset),\n                        fontsize=fz)\n    ax.quiver(location_df.loc[b_coords, \"longitude\"],\n              location_df.loc[b_coords, \"latitude\"], \n              (location_df.loc[c_coords, \"longitude\"]-location_df.loc[b_coords, \"longitude\"]), \n              (location_df.loc[c_coords, \"latitude\"]-location_df.loc[b_coords, \"latitude\"]), \n              angles='xy', scale_units='xy', scale=1)    \n    \n    if angle > 0: \n        sign = \"Counterclockwise\"\n    if angle < 0: \n        sign = \"Clockwise\"\n    if angle == 0:\n        sign = \"Colinear\"\n    plt.title(f\"Direction = {sign}, {angle}\")\n    plt.legend()\n    plt.show()\n\n# Arcs defined as A->B and A->C where A is the intersection\nintersect_pts = intersection_of_gc(\"boulder\", \"boston\", \"reykjavík\", \"johannesburg\")\n\ndirect_angle = directed_angle(a_coords=intersect_pts[0],\n                              b_coords=\"boulder\",\n                              c_coords=\"reykjavík\")\n\nplot_gc_directed_angle(a_coords=intersect_pts[0],\n                       b_coords=\"boulder\",\n                       c_coords=\"reykjavík\",\n                       angle=direct_angle)\n\n# Arcs defined as A->B and A->C where A is the intersection\nintersect_pts = intersection_of_gc(\"boulder\", \"boston\", \"reykjavík\", \"johannesburg\")\n\ndirect_angle = directed_angle(a_coords=intersect_pts[-1],\n                              b_coords=\"boulder\",\n                              c_coords=\"reykjavík\")\n\nplot_gc_directed_angle(a_coords=intersect_pts[-1],\n                       b_coords=\"boulder\",\n                       c_coords=\"reykjavík\",\n                       angle=direct_angle)\n\n# Arcs defined as A->B and A->C where A is the intersection\nintersect_pts = intersection_of_gc(\"zambezi\", \"boston\", \"greenwich\", \"johannesburg\")\n\ndirect_angle = directed_angle(a_coords=intersect_pts[0],\n                              b_coords=\"zambezi\",\n                              c_coords=\"greenwich\")\n\nplot_gc_directed_angle(a_coords=intersect_pts[0],\n                       b_coords=\"zambezi\",\n                       c_coords=\"reykjavík\",\n                       angle=direct_angle)\n\n# Arcs defined as A->B and A->C where A is the intersection\nintersect_pts = intersection_of_gc(\"zambezi\", \"boston\", \"greenwich\", \"johannesburg\")\n\ndirect_angle = directed_angle(a_coords=intersect_pts[-1],\n                              b_coords=\"zambezi\",\n                              c_coords=\"greenwich\")\n\nplot_gc_directed_angle(a_coords=intersect_pts[-1],\n                       b_coords=\"zambezi\",\n                       c_coords=\"reykjavík\",\n                       angle=direct_angle)\n\n","type":"content","url":"/notebooks/tutorials/angles#plot-directed-angle","position":19},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Working with Spherical Triangles formed by great circle arcs (TODO)","lvl2":"Calculate the Directed Angle of two Great Circle paths based on an intersection point"},"type":"lvl3","url":"/notebooks/tutorials/angles#working-with-spherical-triangles-formed-by-great-circle-arcs-todo","position":20},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Working with Spherical Triangles formed by great circle arcs (TODO)","lvl2":"Calculate the Directed Angle of two Great Circle paths based on an intersection point"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/angles#working-with-spherical-triangles-formed-by-great-circle-arcs-todo","position":21},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/tutorials/angles#summary","position":22},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Summary"},"content":"TODO","type":"content","url":"/notebooks/tutorials/angles#summary","position":23},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/tutorials/angles#whats-next","position":24},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"What’s next?","lvl2":"Summary"},"content":"Spherical Polygons and Areas\n\n","type":"content","url":"/notebooks/tutorials/angles#whats-next","position":25},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/tutorials/angles#resources-and-references","position":26},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Resources and references"},"content":"","type":"content","url":"/notebooks/tutorials/angles#resources-and-references","position":27},{"hierarchy":{"lvl1":"Spherical Polygons and Areas"},"type":"lvl1","url":"/notebooks/tutorials/polygon-area","position":0},{"hierarchy":{"lvl1":"Spherical Polygons and Areas"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/polygon-area","position":1},{"hierarchy":{"lvl1":"Spherical Polygons and Areas"},"type":"lvl1","url":"/notebooks/tutorials/polygon-area#spherical-polygons-and-areas","position":2},{"hierarchy":{"lvl1":"Spherical Polygons and Areas"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#spherical-polygons-and-areas","position":3},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#overview","position":4},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Overview"},"content":"Determine the calculations of a spherical polygons based on a unit sphere.\n\nDetermine clockwise/counterclockwise ordering of points on spherical polygon\n\nArea and Permieter of quadrilateral patch on a unit sphere\n\nDetermine if a given point is within a spherical polygon\n\nMean center of spherical polygon\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#overview","position":5},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#prerequisites","position":6},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\n\n\nPandas\n\nNecessary\n\n\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 40 minutes\n\n\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#prerequisites","position":7},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#imports","position":8},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Imports"},"content":"Import Packages\n\nSetup location dataframe with coordinates\n\nimport pandas as pd       # reading in data for location information from text file\nimport numpy as np        # working with arrays, vectors, cross/dot products, and radians\n\nfrom pyproj import Geod   # working with the Earth as an ellipsod (WGS-84)\n\nfrom shapely.geometry import Point\nfrom shapely.geometry.polygon import Polygon\n\nimport matplotlib.pyplot as plt                        # plotting a graph\nfrom cartopy import crs as ccrs, feature as cfeature   # plotting a world map\n\n# Get all Coordinates for Locations\nlocation_df = pd.read_csv(\"../location_full_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df.head()\n\nlocation_df.index = location_df[\"name\"]\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#imports","position":9},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Determine clockwise/counterclockwise ordering of points on spherical polygon"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#determine-clockwise-counterclockwise-ordering-of-points-on-spherical-polygon","position":10},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Determine clockwise/counterclockwise ordering of points on spherical polygon"},"content":"True: when input points are in a clockwise order\n\nFalse: when input points are in a counterclockwise (or co-linear) order","type":"content","url":"/notebooks/tutorials/polygon-area#determine-clockwise-counterclockwise-ordering-of-points-on-spherical-polygon","position":11},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl3":"Shoelace Formula for Signed Polygon Area","lvl2":"Determine clockwise/counterclockwise ordering of points on spherical polygon"},"type":"lvl3","url":"/notebooks/tutorials/polygon-area#shoelace-formula-for-signed-polygon-area","position":12},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl3":"Shoelace Formula for Signed Polygon Area","lvl2":"Determine clockwise/counterclockwise ordering of points on spherical polygon"},"content":"TODO\n\ndef is_clockwise(pt_lst=None):\n    # signed polygon area -> shoelace formula\n    # positive = counterclockwise, negative = clockwise\n    area = 0\n    for i in range(0, len(pt_lst)):\n        if i+1 < len(pt_lst):\n            area += location_df.loc[pt_lst[i], \"latitude\"] * location_df.loc[pt_lst[i+1], \"longitude\"]\n            area -= location_df.loc[pt_lst[i+1], \"latitude\"]  * location_df.loc[pt_lst[i], \"longitude\"]\n        #area /= 2 # determine full sign area, unneeded when just working with signs\n    if area < 0: \n        print(\"clockwise -> negative\")\n        return True\n    if area > 0:\n        print(\"counterclockwise -> positive\")\n        return False\n    if area == 0:\n        print(\"non-collinear -> zero\") #https://en.wikipedia.org/wiki/Curve_orientation\n        return False\n\nis_clockwise([\"boulder\", \"boston\", \"houston\"])\n\ndef plot_clockwise(pt_lst=None,\n                   lon_west=-180, lon_east=180,\n                   lat_south=-90, lat_north=90):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n\n    # plot arrow between points in order\n    for i, pt in enumerate(pt_lst):\n        if i+1 < len(pt_lst):\n            ax.quiver(location_df.loc[pt_lst[i], \"longitude\"],\n                      location_df.loc[pt_lst[i], \"latitude\"], \n                      (location_df.loc[pt_lst[i+1], \"longitude\"]-location_df.loc[pt_lst[i], \"longitude\"]), \n                      (location_df.loc[pt_lst[i+1], \"latitude\"]-location_df.loc[pt_lst[i], \"latitude\"]), \n                      angles='xy', scale_units='xy', scale=1)   \n   # plot points\n    longitudes = [location_df.loc[x, \"longitude\"] for x in pt_lst] # longitude\n    latitudes = [location_df.loc[y, \"latitude\"] for y in pt_lst] # latitude\n    plt.scatter(longitudes, latitudes, s=100, c=\"red\")\n    if is_clockwise(pt_lst):\n        clockwise = \"Clockwise\"\n    else:\n        clockwise = \"Counterclockwise\"\n    plt.title(clockwise)\n    plt.show()\n\nplot_clockwise([\"boulder\", \"boston\", \"houston\"], -130, -60, 20, 60)\n\nplot_clockwise([\"houston\", \"boston\", \"boulder\"], -130, -60, 20, 60)\n\nplot_clockwise([\"boulder\", \"boston\", \"greenwich\", \"cairo\", \"timbuktu\"])\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#shoelace-formula-for-signed-polygon-area","position":13},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Area and Perimeter of quadrilateral patch"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#area-and-perimeter-of-quadrilateral-patch","position":14},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Area and Perimeter of quadrilateral patch"},"content":"\n\ndef area_of_polygon_ellps(poly_pts=None):\n    geod = Geod(ellps=\"WGS84\")\n    longitudes = [location_df.loc[pt, \"longitude\"] for pt in poly_pts]\n    latitudes = [location_df.loc[pt, \"latitude\"] for pt in poly_pts]\n    poly_area_m, poly_perimeter_m = geod.polygon_area_perimeter(longitudes, latitudes)\n    return abs(poly_area_m) * 1e-6, poly_perimeter_m/1000 # km^2 and km\n\ndef area_of_polygon_unit_sphere(poly_pts=None):\n    geod = Geod(ellps=\"sphere\") # 'sphere': {'a': 6370997.0, 'b': 6370997.0, 'description': 'Normal Sphere (r=6370997)'\n    longitudes = [location_df.loc[pt, \"longitude\"] for pt in poly_pts]\n    latitudes = [location_df.loc[pt, \"latitude\"] for pt in poly_pts]\n    poly_area_m, poly_perimeter_m = geod.polygon_area_perimeter(longitudes, latitudes)\n    return abs(poly_area_m) * 1e-6, poly_perimeter_m/1000 # km^2 and km\n\ndef plot_area(pt_lst=None,\n                   lon_west=-180, lon_east=180,\n                   lat_south=-90, lat_north=90):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n\n   # plot points\n    longitudes = [location_df.loc[x, \"longitude\"] for x in pt_lst] # longitude\n    latitudes = [location_df.loc[y, \"latitude\"] for y in pt_lst] # latitude\n    plt.scatter(longitudes, latitudes, s=100, c=\"red\")\n    plt.fill(longitudes, latitudes, alpha=0.5)\n\n    area_ellps, perimeter_ellps = area_of_polygon_ellps(pt_lst)\n    area_us, perimeter_us = area_of_polygon_unit_sphere(pt_lst)\n    print(f\"Ellipsoid Area   = {area_ellps} km^2\")\n    print(f\"Unit Sphere Area = {area_us} km^2\")\n    plt.title(f\"Roughly {(area_ellps/509600000)*100:.2f}% ({(area_us/509600000)*100:.2f}%) of the Earth's Surface\")\n    plt.show()\n\narea_ellps, perimeter_ellps = area_of_polygon_ellps([\"boulder\", \"boston\",\n                                             \"arecibo\", \"houston\"])\narea_us, perimeter_us = area_of_polygon_unit_sphere([\"boulder\", \"boston\",\n                                             \"arecibo\", \"houston\"])\nprint(f\"Area Ellipsoid   = {area_ellps} km^2\")\nprint(f\"Area Unit Sphere = {area_us} km^2\")\nprint(f\"Perimeter Ellipsoid = {perimeter_ellps} km\")\nprint(f\"Perimeter Unit SPhere = {perimeter_us} km\")\nprint(f\"Roughly {(area_ellps/509600000)*100:.2f}% of the Earth's Surface\")\nprint(f\"Roughly {(area_us/509600000)*100:.2f}% of the Earth's Surface\")\n\nplot_area([\"boulder\", \"boston\", \"greenwich\", \"cairo\", \"arecibo\", \"houston\"])\n\nplot_area([\"redwoods\", \"rockford\", \"boston\", \"houston\",], -130, -60, 20, 60)\n\nplot_area([\"redwoods\", \"boston\", \"houston\"], -130, -60, 20, 60)\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#area-and-perimeter-of-quadrilateral-patch","position":15},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl3":"TODO","lvl2":"Area and Perimeter of quadrilateral patch"},"type":"lvl3","url":"/notebooks/tutorials/polygon-area#todo","position":16},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl3":"TODO","lvl2":"Area and Perimeter of quadrilateral patch"},"content":"Fix invalid overlapping polygon by re-ordering points into a clockwise order.\n\nplot_area([\"boulder\", \"boston\", \"houston\", \"boston\", \"cairo\", \"arecibo\", \"greenwich\"])\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#todo","position":17},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Determine if a given point is within a spherical polygon"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#determine-if-a-given-point-is-within-a-spherical-polygon","position":18},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Determine if a given point is within a spherical polygon"},"content":"Single or list of points\n\ndef polygon_contains_points(pt_lst=None, polygon_pts=None, tolerance_m=1):\n    # tolerance in meters\n    longitudes = [location_df.loc[pt, \"longitude\"] for pt in polygon_pts]\n    latitudes = [location_df.loc[pt, \"latitude\"] for pt in polygon_pts]\n    lat_lon_coords = tuple(zip(longitudes, latitudes))\n    polygon = Polygon(lat_lon_coords)\n    contains = np.vectorize(lambda pt: polygon.contains(Point((location_df.loc[pt, \"longitude\"],\n                                                               location_df.loc[pt, \"latitude\"]))))\n    contained_by_polygon = contains(np.array(pt_lst))\n    return contained_by_polygon\n\ndef plot_polygon_pts(pt_lst=None, polygon_pts=None, tolerance_m=1,\n                   lon_west=-180, lon_east=180,\n                   lat_south=-90, lat_north=90):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n\n    # plot polygon points\n    longitudes = [location_df.loc[x, \"longitude\"] for x in polygon_pts] # longitude\n    latitudes = [location_df.loc[y, \"latitude\"] for y in polygon_pts] # latitude\n    plt.scatter(longitudes, latitudes, s=50, c=\"blue\")\n    plt.fill(longitudes, latitudes, alpha=0.5)\n\n    # plot check points\n    pt_lst = np.array(pt_lst)\n    contains_pts = polygon_contains_points(pt_lst, polygon_pts, tolerance_m)\n    longitudes = [location_df.loc[x, \"longitude\"] for x in pt_lst[contains_pts]] # longitude\n    latitudes = [location_df.loc[y, \"latitude\"] for y in pt_lst[contains_pts]] # latitude\n    plt.scatter(longitudes, latitudes, s=100, c=\"green\", label=\"Within Polygon\")\n    longitudes = [location_df.loc[x, \"longitude\"] for x in pt_lst[~contains_pts]] # longitude\n    latitudes = [location_df.loc[y, \"latitude\"] for y in pt_lst[~contains_pts]] # latitude\n    plt.scatter(longitudes, latitudes, s=100, c=\"red\", label=\"Not within Polygon\")\n\n    plt.legend(loc=\"lower left\")\n    plt.title(f\"Points contained within polygon (tolerance {tolerance_m} m) = {pt_lst[contains_pts]}, not contained = {pt_lst[~contains_pts]}\")\n    plt.show()\n\npolygon_contains_points([\"boulder\"], [\"redwoods\", \"boston\", \"houston\"], 1)\n\nplot_polygon_pts([\"boulder\"], [\"redwoods\", \"boston\", \"houston\"], 1,\n               -130, -60, 20, 60)\n\npolygon_contains_points([\"cape canaveral\"], [\"redwoods\", \"boston\", \"houston\"], 1)\n\nplot_polygon_pts([\"cape canaveral\"], [\"redwoods\", \"boston\", \"houston\"], 1,\n               -130, -60, 20, 60)\n\nplot_polygon_pts([\"boulder\", \"cape canaveral\"], [\"redwoods\", \"boston\", \"houston\"], 1,\n               -130, -60, 20, 60)\n\nplot_polygon_pts([\"boulder\", \"redwoods\"], [\"rockford\", \"boston\", \"cape canaveral\"], 1,\n               -130, -60, 20, 60)\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#determine-if-a-given-point-is-within-a-spherical-polygon","position":19},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Mean center of spherical polygon"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#mean-center-of-spherical-polygon","position":20},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Mean center of spherical polygon"},"content":"\n\ndef polygon_centroid(polygon_pts=None):\n    longitudes = [location_df.loc[x, \"longitude\"] for x in polygon_pts]\n    latitudes = [location_df.loc[y, \"latitude\"] for y in polygon_pts]\n    lat_lon_coords = tuple(zip(longitudes, latitudes))\n    polygon = Polygon(lat_lon_coords)\n    return (polygon.centroid.y, polygon.centroid.x)\n\npolygon_centroid([\"boulder\", \"boston\", \"houston\"])\n\ndef plot_centroid(polygon_pts=None,\n                   lon_west=-180, lon_east=180,\n                   lat_south=-90, lat_north=90):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n\n   # plot polygon points\n    longitudes = [location_df.loc[x, \"longitude\"] for x in polygon_pts] # longitude\n    latitudes = [location_df.loc[y, \"latitude\"] for y in polygon_pts] # latitude\n    plt.scatter(longitudes, latitudes, s=50, c=\"blue\")\n    plt.fill(longitudes, latitudes, alpha=0.5)\n\n    # plot check point\n    centeroid = polygon_centroid(polygon_pts)\n    plt.scatter(centeroid[1], centeroid[0], s=100, c=\"red\")\n    plt.title(f\"Centroid = {centeroid}\")\n    plt.show()\n\nplot_centroid([\"boulder\", \"boston\", \"houston\"],\n               -130, -60, 20, 60)\n\nplot_centroid([\"redwoods\", \"boulder\", \"cape canaveral\", \"houston\"],\n               -130, -60, 20, 60)\n\n\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#mean-center-of-spherical-polygon","position":21},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#summary","position":22},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Summary"},"content":"This notebook covers working with spherical polygons to determine the ordering of coordinates, center of polygons, and whether or not a point lies within a spherical polygon\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#summary","position":23},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#resources-and-references","position":24},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Resources and references"},"content":"","type":"content","url":"/notebooks/tutorials/polygon-area#resources-and-references","position":25}]}