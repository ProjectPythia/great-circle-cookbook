{"version":"1","records":[{"hierarchy":{"lvl1":"Great Circle Cookbook"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Great Circle Cookbook"},"content":"\n\n\n\n\n\n\n\n\n\nThis Project Pythia Cookbook covers the background and mathematics of working with great circles and, where available, this cookbook will demonstrate how to determine the features of a great circle with both existing open-source Python packages and through spherical trigonometry","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Motivation"},"type":"lvl2","url":"/#motivation","position":2},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Motivation"},"content":"A great circle is the largest circle that can be drawn onto a sphere (like the Earth) that is the same diameter of the sphere. Great Circle arcs connect two positions on the curved surface of a planet like Earth and are commonly used for navigation that relies on “as-the crow flies” directions like planes, ships, and satellites\n\n\n\nImage Source: \n\nWolfram MathWorld\n\nGreat circles are commonly used in navigation, satellites in remote sensing, and working with coordinates on planets, but can be difficult to find resources to fully explain how to use them.","type":"content","url":"/#motivation","position":3},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Authors"},"type":"lvl2","url":"/#authors","position":4},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Authors"},"content":"Cora Schneck","type":"content","url":"/#authors","position":5},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Contributors","lvl2":"Authors"},"type":"lvl3","url":"/#contributors","position":6},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Contributors","lvl2":"Authors"},"content":"","type":"content","url":"/#contributors","position":7},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Structure"},"type":"lvl2","url":"/#structure","position":8},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Structure"},"content":"This cookbook is broken into two main sections:\n\nFoundations and Terminology\n\nWorking with Great Circles","type":"content","url":"/#structure","position":9},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Foundations and Terminology","lvl2":"Structure"},"type":"lvl3","url":"/#foundations-and-terminology","position":10},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Foundations and Terminology","lvl2":"Structure"},"content":"“Great Circle Terminology”: Covers the important terminology for working with and understanding great circles\n\n“Coordinate Systems”: Covers important terminology and functions required to understand and converted to different types of coordinate systems like Cartesian, Spherical, Polar, and Latitude/Longitude\n\nEach section will make use of plotting to visually demonstrate concepts with matplotlib and cartopy","type":"content","url":"/#foundations-and-terminology","position":11},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl3","url":"/#working-with-great-circles","position":12},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"This is the main section of this notebook and will cover specific details about how to understand and calculate important features in great circles.","type":"content","url":"/#working-with-great-circles","position":13},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"1. Great Circle Arcs and Paths","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl4","url":"/#id-1-great-circle-arcs-and-paths","position":14},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"1. Great Circle Arcs and Paths","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"Distance between Points on a Great Circle Arc\n\nConvert Spherical Distance to Degrees\n\nDetermine the Bearing of a Great Circle Arc\n\nGenerate a Great Circle Arc with Intermediate Points\n\nDetermine the Midpoint of a Great Circle Arc\n\nGenerate a Great Circle Path\n\nDetermine an Antipodal Point","type":"content","url":"/#id-1-great-circle-arcs-and-paths","position":15},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"2. Great Circles and a Point","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl4","url":"/#id-2-great-circles-and-a-point","position":16},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"2. Great Circles and a Point","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"Determine the distance of a point to a great circle arc (cross-track and along-track distance)\n\nDetermine if a point lies on a great circle arc and path (with and without tolerances)","type":"content","url":"/#id-2-great-circles-and-a-point","position":17},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"3. Great Circles and Parallels","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl4","url":"/#id-3-great-circles-and-parallels","position":18},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"3. Great Circles and Parallels","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"Determine the maximum latitude on a Great Circle Path\n\nDetermine the minimum latitude on a Great Great path","type":"content","url":"/#id-3-great-circles-and-parallels","position":19},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"4. Intersections of Great Circles","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl4","url":"/#id-4-intersections-of-great-circles","position":20},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"4. Intersections of Great Circles","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"Find the intersection of two great circle paths","type":"content","url":"/#id-4-intersections-of-great-circles","position":21},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"5. Angles and Great Circles","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl4","url":"/#id-5-angles-and-great-circles","position":22},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"5. Angles and Great Circles","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"Determine the acute and obtuse angle formed by two great circle paths\n\nDetermine the directed angle formed by two great circle paths based on an intersection point","type":"content","url":"/#id-5-angles-and-great-circles","position":23},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"6. Spherical Polygons and Areas","lvl3":"Working with Great Circles","lvl2":"Structure"},"type":"lvl4","url":"/#id-6-spherical-polygons-and-areas","position":24},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl4":"6. Spherical Polygons and Areas","lvl3":"Working with Great Circles","lvl2":"Structure"},"content":"Calculate area and permieter of quadrilateral patch on a unit sphere\n\nDetermine if a given point is within a spherical polygon\n\nMean center of spherical polygon","type":"content","url":"/#id-6-spherical-polygons-and-areas","position":25},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Running the Notebooks"},"type":"lvl2","url":"/#running-the-notebooks","position":26},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl2":"Running the Notebooks"},"content":"You can either run the notebook using \n\nBinder or on your local machine.","type":"content","url":"/#running-the-notebooks","position":27},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-binder","position":28},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"content":"The simplest way to interact with a Jupyter Notebook is through\n\n\nBinder, which enables the execution of a\n\n\nJupyter Book in the cloud. The details of how this works are not\nimportant for now. All you need to know is how to launch a Pythia\nCookbooks chapter via Binder. Simply navigate your mouse to\nthe top right corner of the book chapter you are viewing and click\non the rocket ship icon, (see figure below), and be sure to select\n“launch Binder”. After a moment you should be presented with a\nnotebook that you can interact with. I.e. you’ll be able to execute\nand even change the example programs. You’ll see that the code cells\nhave no output at first, until you execute them by pressing\nShift+Enter. Complete details on how to interact with\na live Jupyter notebook are described in \n\nGetting Started with\nJupyter.","type":"content","url":"/#running-on-binder","position":29},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-your-own-machine","position":30},{"hierarchy":{"lvl1":"Great Circle Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"content":"If you are interested in running this material locally on your computer, you will need to follow this workflow:\n\nClone the https://github.com/ProjectPythia/great-circle-cookbook repository: git clone https://github.com/ProjectPythia/great-circle-cookbook.git\n\nMove into the great-circle-cookbook directorycd great-circle-cookbook\n\nCreate and activate your conda environment from the environment.yml fileconda env create -f environment.yml\nconda activate cookbook-gc\n\nMove into the notebooks directory and start up Jupyterlabcd notebooks/\njupyter lab","type":"content","url":"/#running-on-your-own-machine","position":31},{"hierarchy":{"lvl1":"Great Circle Terminology"},"type":"lvl1","url":"/notebooks/foundations/terminology","position":0},{"hierarchy":{"lvl1":"Great Circle Terminology"},"content":"\n\n","type":"content","url":"/notebooks/foundations/terminology","position":1},{"hierarchy":{"lvl1":"Great Circle Terminology"},"type":"lvl1","url":"/notebooks/foundations/terminology#great-circle-terminology","position":2},{"hierarchy":{"lvl1":"Great Circle Terminology"},"content":"\n\n\n\n","type":"content","url":"/notebooks/foundations/terminology#great-circle-terminology","position":3},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/foundations/terminology#overview","position":4},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Overview"},"content":"Great circles are powerful tools and historically were commonly used in the navigation of ships. Today, they are a common tool for pilots to plot paths “as-the-crow-flies” as well as in geoscience when  working with remote sensing via satellites that pass over the globe in long arcs.\n\nThe mathematics of great circles make use of spherical geometry, where, rather than lines, long arcs are drawn along the surface of a sphere. While spherical geometry played an important role historically in the fields of astronomy and navigation, its teaching has largely fallen out of favor since the 1950’s making finding comphrenshive resources difficult.\n\nThis notebook will cover the important and unique terminology used when working with great circles and spherical geometry.\n\nGreat Circles\n\nSpherical Geometry\n\nEllipsoids vs. Spheres\n\nGeodesy\n\nPython Packages\n\nA Note on Resources\n\n","type":"content","url":"/notebooks/foundations/terminology#overview","position":5},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/foundations/terminology#prerequisites","position":6},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Prerequisites"},"content":"Time to learn: 20 minutes\n\n\n\n","type":"content","url":"/notebooks/foundations/terminology#prerequisites","position":7},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Great Circles"},"type":"lvl2","url":"/notebooks/foundations/terminology#great-circles","position":8},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Great Circles"},"content":"","type":"content","url":"/notebooks/foundations/terminology#great-circles","position":9},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Great Circle Path vs. Great Circle Arc","lvl2":"Great Circles"},"type":"lvl3","url":"/notebooks/foundations/terminology#great-circle-path-vs-great-circle-arc","position":10},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Great Circle Path vs. Great Circle Arc","lvl2":"Great Circles"},"content":"A great circle path is the full path formed by the intersection of a plane which also passes through the center of the sphere. For example, the equator is an example of a great circle path on the Earth. The equator can be imagined as the path formed by a plane cutting through the center of the planet and intersecting the center. A great circle path is a closed path (-180 to 180 degrees longitude) that forms around the sphere.\n\n\n\nAll great circles:\n\nIntersect the center of the Earth\n\nDivide the Earth in half\n\nA great circle arc is a small subsection of a great circle path, representing an arc between two points on the surface of a sphere. The arc will represent the shortest distance between any two points on the surface of the Earth. An arc can be formed with:\n\nTwo points\n\nOr: One point, a bearing, and a distance\n\n","type":"content","url":"/notebooks/foundations/terminology#great-circle-path-vs-great-circle-arc","position":11},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Spherical Geometry"},"type":"lvl2","url":"/notebooks/foundations/terminology#spherical-geometry","position":12},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Spherical Geometry"},"content":"","type":"content","url":"/notebooks/foundations/terminology#spherical-geometry","position":13},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Spherical Trigonometry","lvl2":"Spherical Geometry"},"type":"lvl3","url":"/notebooks/foundations/terminology#spherical-trigonometry","position":14},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Spherical Trigonometry","lvl2":"Spherical Geometry"},"content":"Spherical geometry (and one of it important branches: spherical trigonometry) provide calculations based on the relationshsips between the sides and angles on a sphere that are commonly used in right-angled triangles. Spheres are unique since unlike flat surfaces, spherical triangles can have internal angles that add up to more than 180 degrees.\n\nFor example, imagine you fly a plane from the Philippines directly North until you reach the top of the Earth (at the North Pole). Then, you turn the plane 50 degrees, and fly down again until you arrive at the starting latitude of Philippines, off the coast of India. Once you have returned to your same starting latitude, you turn 90 degrees and return to the Philippines. By this point, you will have made two 90 degree turns (off the coast of India and the Philippines). So, all the internal angles combined to make this triangle along the Earth are 230 degrees (90 + 90 + 50).\n\nThe sum of the angles of a spherical triangle is not equal to 180°. A sphere is a curved surface, but locally the laws of the flat (planar) Euclidean geometry are good approximations. In a small triangle on the face of the earth, the sum of the angles is only slightly more than 180 degrees\n\nWikipedia: Spherical geometry\n\n\n\nLike a flat 2D triangle, spherical triangles have the own sine and cosine identities that can be used to solve internal angles and the length of sides.","type":"content","url":"/notebooks/foundations/terminology#spherical-trigonometry","position":15},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Law of Cosines","lvl2":"Spherical Geometry"},"type":"lvl3","url":"/notebooks/foundations/terminology#law-of-cosines","position":16},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Law of Cosines","lvl2":"Spherical Geometry"},"content":"“The cosine rule is the fundamental identity of spherical trigonometry: all other identities, including the sine rule, may be derived from the cosine rule” \n\n(Wikipedia)\n\nThe spherical \n\nlaw of cosines states that for the angles A, B, C and opposite sides a, b, c:cos(a) = cos(b)cos(c) + sin(b)sin(c)cos(A)cos(b) = cos(c)cos(a) + sin(c)sin(a)cos(B)cos(c) = cos(a)cos(b) + sin(a)sin(b)cos(C)","type":"content","url":"/notebooks/foundations/terminology#law-of-cosines","position":17},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Law of Sines","lvl2":"Spherical Geometry"},"type":"lvl3","url":"/notebooks/foundations/terminology#law-of-sines","position":18},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Law of Sines","lvl2":"Spherical Geometry"},"content":"The law of sines can be constructed from the law of cosines, where the spherical \n\nlaw of sines states that for the angles A, B, and C and the opposite of the sides a, b, c:\\frac{sin(A)}{sin(a)} = \\frac{sin(B)}{sin(b)} = \\frac{sin(C)}{sin(c)}\n\n","type":"content","url":"/notebooks/foundations/terminology#law-of-sines","position":19},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Ellipsoids vs. Spheres"},"type":"lvl2","url":"/notebooks/foundations/terminology#ellipsoids-vs-spheres","position":20},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Ellipsoids vs. Spheres"},"content":"The earth is not round, instead it is an irregular ellipsoid known as a an oblate spheroid where the poles are slightly flatter and the equator bulges out. Spherical trigonometry typically assumes that calculations are occurring on a perfect sphere. For much of history this approximiation was accurate enough to allow ships to find their way to ports, but with increasingly technologically advanced and precise tools (like satellites) this discrepancy becomes more and more pronounced. Any calculation on Earth that assumes the planet is a perfect sphere, and without additional corrections, will contain an error up to 0.3% (22 km) (\n\nsee more).\n\nLearn More!\n\n\n\nThe various Python geodetic tools that we will in this cookbook will attempt to account for these errors by making use of different sized ellipsoids with flattening parameters.\n\n","type":"content","url":"/notebooks/foundations/terminology#ellipsoids-vs-spheres","position":21},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Geodesy"},"type":"lvl2","url":"/notebooks/foundations/terminology#geodesy","position":22},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Geodesy"},"content":"Geodesy is the complex science of measuring the Earth’s size and shape (as well as orientation and gravity field, but that is out of the scope of this notebook).\n\nLearn more!\n\nThe methods of measuring Earth have changed dramatically through history from physical survey tools to modern GPS.","type":"content","url":"/notebooks/foundations/terminology#geodesy","position":23},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Geodesic","lvl2":"Geodesy"},"type":"lvl3","url":"/notebooks/foundations/terminology#geodesic","position":24},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"Geodesic","lvl2":"Geodesy"},"content":"A geodesic is the shortest curved path between any two points on a surface. A “straight line” on the surface of a curved surface (like a sphere) will form an arc. A great circle arc is a special type of arc that is formed by a plane intersecting the center of a sphere.\n\nIf an insect is placed on a surface and continually walks “forward”, by definition it will trace out a geodesic\n\nWikipedia: Geodesic\n\n\n\nThis is especially apparent when working with satellite data where the apparent “straight path” that a satellite will trace across the the surface of a planet turns into an arc or curve on a map.\n\n","type":"content","url":"/notebooks/foundations/terminology#geodesic","position":25},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Python Packages"},"type":"lvl2","url":"/notebooks/foundations/terminology#python-packages","position":26},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Python Packages"},"content":"For the purpose of this notebook we will be taking advantage of two geoscience Python packages:\n\npyproj: Python package to work with catographic projections and coordinate transformations library\n\ngeopy:  Python package to work with spherical distances\n\npyproj and geopy both take advantage of different types of (optional) ellipsoids, where a is the radius (semi-major or equatorial axis radius) in meters, rf is the reciprocal flattening, and b (where available) is the semi-minor axis (polar axis radius).\n\nimport pyproj\nfor key in pyproj.list.get_ellps_map().keys():\n    print(f\"{key} = {pyproj.list.get_ellps_map()[key]}\")\n\nBy default, pyproj has more options for ellipsoids, but several of these ellipsoids are also available in geopy as well, with a radius in kilometers instead of meters\n\nfrom geopy import distance\nfor key in distance.ELLIPSOIDS.keys():\n    print(f\"{key} = {distance.ELLIPSOIDS[key]}\")\n\n","type":"content","url":"/notebooks/foundations/terminology#python-packages","position":27},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"The standard reference ellipsoid for working with Earth is WGS-84","lvl2":"Python Packages"},"type":"lvl3","url":"/notebooks/foundations/terminology#the-standard-reference-ellipsoid-for-working-with-earth-is-wgs-84","position":28},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"The standard reference ellipsoid for working with Earth is WGS-84","lvl2":"Python Packages"},"content":"geopy by default makes use of WGS-84  which is a a unified global ellipsoid model that is used for GPS collected from satellites to calculate extremely preise measurements of the Earth. For the purpose of this notebook, this is the ellipsoid model we will be working with.\n\nprint(pyproj.list.get_ellps_map()[\"WGS84\"])\nprint(distance.ELLIPSOIDS[\"WGS-84\"])\n\nWGS-84 is an ellipsoid with a semi-major axis of 6378137.0 meters, an inverse (reciprocal) flattening feature of 298.257223563, and a flattening factor of 0.0033528106647474805.\n\nLearn more!\n\n","type":"content","url":"/notebooks/foundations/terminology#the-standard-reference-ellipsoid-for-working-with-earth-is-wgs-84","position":29},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"An Important Note on Resources"},"type":"lvl2","url":"/notebooks/foundations/terminology#an-important-note-on-resources","position":30},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"An Important Note on Resources"},"content":"Spherical geometry and resources associated with working with great circles can be difficult to find\n\nHere are a list of some for working mathematically with great circles:\n\nEd Williams “Avitation Formulary”\n\nMovable Type Scripts\n\n“Heavenly Mathematics: The Forgotten Art of Spherical Trigonometry” by Glen Van Brummelen\n\n“Spherical Trigonometry: A Comprehensive Approach” by Ira Arevalo Fajardo\n\n\n\n","type":"content","url":"/notebooks/foundations/terminology#an-important-note-on-resources","position":31},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/foundations/terminology#summary","position":32},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl2":"Summary"},"content":"A great circle is formed by a plane intersecting a sphere and the center, like the equator.\n\nGreat circles make use of spherical geometry to measure features on the curved surface of a unit sphere. However, planets like Earth are not perfect spheres and to account for the error are combined with geodesic calculations to reduce the error in final calculations.","type":"content","url":"/notebooks/foundations/terminology#summary","position":33},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/foundations/terminology#whats-next","position":34},{"hierarchy":{"lvl1":"Great Circle Terminology","lvl3":"What’s next?","lvl2":"Summary"},"content":"How do we measure a specific place on the Earth or any sphere?\n\nUp next: Coordinates and Great Circles","type":"content","url":"/notebooks/foundations/terminology#whats-next","position":35},{"hierarchy":{"lvl1":"Coordinate Types"},"type":"lvl1","url":"/notebooks/foundations/coordinates","position":0},{"hierarchy":{"lvl1":"Coordinate Types"},"content":"\n\n","type":"content","url":"/notebooks/foundations/coordinates","position":1},{"hierarchy":{"lvl1":"Coordinate Types"},"type":"lvl1","url":"/notebooks/foundations/coordinates#coordinate-types","position":2},{"hierarchy":{"lvl1":"Coordinate Types"},"content":"\n\n\n\n","type":"content","url":"/notebooks/foundations/coordinates#coordinate-types","position":3},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/foundations/coordinates#overview","position":4},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Overview"},"content":"Great circles can use a diverse variety of different types of coordinates. This notebook will cover the different types of coordinates that are used when calculating great circles and how to convert between them. This notebook will also begin to show how to plot coordinates and their associated great circle arcs on a map of Earth.\n\nTypes of Coordinates\n\nConvert Coordinates to All Coordinate Types\n\nPlot Coordinates on a World Map\n\n","type":"content","url":"/notebooks/foundations/coordinates#overview","position":5},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/foundations/coordinates#prerequisites","position":6},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 20 minutes\n\n\n\n","type":"content","url":"/notebooks/foundations/coordinates#prerequisites","position":7},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/foundations/coordinates#imports","position":8},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Imports"},"content":"\n\nimport numpy as np                                     # working with degrees and radians\nimport pandas as pd                                    # working with data and dataframes\n\nimport matplotlib.pyplot as plt                        # plotting a graph\nfrom cartopy import crs as ccrs, feature as cfeature   # plotting a world map\n\n","type":"content","url":"/notebooks/foundations/coordinates#imports","position":9},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Types of Coordinates"},"type":"lvl2","url":"/notebooks/foundations/coordinates#types-of-coordinates","position":10},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Types of Coordinates"},"content":"\n\n","type":"content","url":"/notebooks/foundations/coordinates#types-of-coordinates","position":11},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Geodetic Coordinates","lvl2":"Types of Coordinates"},"type":"lvl3","url":"/notebooks/foundations/coordinates#geodetic-coordinates","position":12},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Geodetic Coordinates","lvl2":"Types of Coordinates"},"content":"Geodetic coordinates are latitude and longtiude and are measured from -90° South to 90° North and -180° East to 180° West measured from Greenwich. Geodetic coordinates also include a geodetic height, which on Earth represents the radius of the planet.\n\n\n\n0 degrees latitude represents the middle of Earth at the equator while 0 degrees longitude was arbitrarily chosen to lie in the Royal Observatory in Greenwich (in London, England). This is known as the \n\nPrime Meridian and due to its arbitrary definition the location of the Prime Meridian have varied throughout history.\n\n","type":"content","url":"/notebooks/foundations/coordinates#geodetic-coordinates","position":13},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Cartesian Coordinates","lvl2":"Types of Coordinates"},"type":"lvl3","url":"/notebooks/foundations/coordinates#cartesian-coordinates","position":14},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Cartesian Coordinates","lvl2":"Types of Coordinates"},"content":"Cartesian coordinates describe points in space based on perpendicular axis lines that meet at a single point of origin, where any point’s position is described based on the distance to the origin along xyz axis.\n\n\n\nImage Source: \n\nThree Dimensional Cartesian Coordinate System","type":"content","url":"/notebooks/foundations/coordinates#cartesian-coordinates","position":15},{"hierarchy":{"lvl1":"Coordinate Types","lvl4":"How to Convert from Geodetic to Cartesian Coordinates","lvl3":"Cartesian Coordinates","lvl2":"Types of Coordinates"},"type":"lvl4","url":"/notebooks/foundations/coordinates#how-to-convert-from-geodetic-to-cartesian-coordinates","position":16},{"hierarchy":{"lvl1":"Coordinate Types","lvl4":"How to Convert from Geodetic to Cartesian Coordinates","lvl3":"Cartesian Coordinates","lvl2":"Types of Coordinates"},"content":"Assuming the Earth’s radius is 6378137 meters then:x = radius * cos(latitude) * cos(longitude)y = radius * cos(latitude) * sin(longitude)z = radius * sin(latitude)\n\nHowever, on a unit sphere, we can consider the radius to be 1.\n\ndef cartesian_coordinates(latitude=None, longitude=None):\n    radius = 1\n    latitude = np.deg2rad(latitude)\n    longitude = np.deg2rad(longitude)\n    cart_x = radius * np.cos(latitude) * np.cos(longitude)\n    cart_y = radius * np.cos(latitude) * np.sin(longitude)\n    cart_z = radius * np.sin(latitude)\n    return cart_x, cart_y, cart_z\n\n","type":"content","url":"/notebooks/foundations/coordinates#how-to-convert-from-geodetic-to-cartesian-coordinates","position":17},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Spherical Coordinates","lvl2":"Types of Coordinates"},"type":"lvl3","url":"/notebooks/foundations/coordinates#spherical-coordinates","position":18},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Spherical Coordinates","lvl2":"Types of Coordinates"},"content":"Spherical coordinates describe points in space based on three values: radial distance (rho, r) along the radial line between point and the origin, polar angle (theta, θ) between the radial line and the polar axis, and azimuth angle (phi, φ) which is the angle of rotation of the radial line around the polar axis. With a fixed radius, the 3-point coordinates (r, θ, φ) provide a coordinate along a sphere.\n\nRadial distance (r): distance from center to surface of sphere\n\nPolar angle (θ): angle between radial line and polar axis\n\nAzimuth angle (φ): angle around polar axis\n\n\n\nImage Source: \n\nWikipedia - Spherical Coordinate System","type":"content","url":"/notebooks/foundations/coordinates#spherical-coordinates","position":19},{"hierarchy":{"lvl1":"Coordinate Types","lvl4":"Convert from Cartesian to Spherical Coordinates","lvl3":"Spherical Coordinates","lvl2":"Types of Coordinates"},"type":"lvl4","url":"/notebooks/foundations/coordinates#convert-from-cartesian-to-spherical-coordinates","position":20},{"hierarchy":{"lvl1":"Coordinate Types","lvl4":"Convert from Cartesian to Spherical Coordinates","lvl3":"Spherical Coordinates","lvl2":"Types of Coordinates"},"content":"ρ^2 = x^2 + y^2 + z^2tan(θ) = \\frac{y}{x}φ = arccos(\\frac{x}{\\sqrt{x^2 + y^2 + z^2}})\n\nWhere, rho (ρ), theta (θ), phi (φ):ρ = \\sqrt{x^2 + y^2 + z^2}θ = arctan(\\frac{y}{x})φ = arccos(\\frac{x}{ρ})\n\ndef cartesian_to_spherical_coordinates(cart_x=None, cart_y=None, cart_z=None):\n    rho = np.sqrt(cart_x**2 + cart_y**2 + cart_z**2)\n    theta = np.arctan(cart_y/cart_x)\n    phi = np.arccos(cart_z / rho)\n    return rho, theta, phi \n\n","type":"content","url":"/notebooks/foundations/coordinates#convert-from-cartesian-to-spherical-coordinates","position":21},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Polar Coordinates","lvl2":"Types of Coordinates"},"type":"lvl3","url":"/notebooks/foundations/coordinates#polar-coordinates","position":22},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Polar Coordinates","lvl2":"Types of Coordinates"},"content":"Polar coordinates are a combination of latitude, longitude, and altitude from the center of the sphere (based on the radius).","type":"content","url":"/notebooks/foundations/coordinates#polar-coordinates","position":23},{"hierarchy":{"lvl1":"Coordinate Types","lvl4":"Convert Geodetic to Polar Coordinates","lvl3":"Polar Coordinates","lvl2":"Types of Coordinates"},"type":"lvl4","url":"/notebooks/foundations/coordinates#convert-geodetic-to-polar-coordinates","position":24},{"hierarchy":{"lvl1":"Coordinate Types","lvl4":"Convert Geodetic to Polar Coordinates","lvl3":"Polar Coordinates","lvl2":"Types of Coordinates"},"content":"Assuming the Earth’s radius is 6378137 meters then:x = cos(latitude) * cos(longitude) * radiusy = cos(latitude) * sin(longitude) * radiusz = sin(latitude) * radius\n\ndef polar_coordinates(latitude=None, longitude=None):\n    earth_radius = 6378137  # meters\n    latitude = np.deg2rad(latitude)\n    longitude = np.deg2rad(longitude)\n    polar_x = np.cos(latitude) * np.sin(longitude) * earth_radius\n    polar_y = np.cos(latitude) * np.cos(longitude) * earth_radius\n    polar_z = np.sin(latitude) * earth_radius\n    return polar_x, polar_y, polar_z\n\n","type":"content","url":"/notebooks/foundations/coordinates#convert-geodetic-to-polar-coordinates","position":25},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Convert City Coordinates to All Coordinate Types"},"type":"lvl2","url":"/notebooks/foundations/coordinates#convert-city-coordinates-to-all-coordinate-types","position":26},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Convert City Coordinates to All Coordinate Types"},"content":"This notebook contains a list of locations (location_coords.txt) (\n\nsee here) with their associated latitude and longitude coordinates. We will use the functions defined above to convert latitude/longitude to all coordinate types and save the output to a new file (location_full_coords.txt). In the future, different functions will require different coordinates to complete their calculations, so it is useful to have all these coordinates values known in advance.\n\n","type":"content","url":"/notebooks/foundations/coordinates#convert-city-coordinates-to-all-coordinate-types","position":27},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Display Coordinates of Cities","lvl2":"Convert City Coordinates to All Coordinate Types"},"type":"lvl3","url":"/notebooks/foundations/coordinates#display-coordinates-of-cities","position":28},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Display Coordinates of Cities","lvl2":"Convert City Coordinates to All Coordinate Types"},"content":"First, we will read in the latitude and longitude coordinates from saved text file location.txt and save the details in a pandas dataframe:\n\nlocation_df = pd.read_csv(\"../location_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df\n\n","type":"content","url":"/notebooks/foundations/coordinates#display-coordinates-of-cities","position":29},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Add Columns for Additional Coordinate Types","lvl2":"Convert City Coordinates to All Coordinate Types"},"type":"lvl3","url":"/notebooks/foundations/coordinates#add-columns-for-additional-coordinate-types","position":30},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"Add Columns for Additional Coordinate Types","lvl2":"Convert City Coordinates to All Coordinate Types"},"content":"We will now add columns to the dataframe for each of the three additional coordinate types: cartesian, spherical, and polar. And finally, we will save the output to a new file we can reference in the future location_full_coords.txt.\n\nlocation_df[\"cart_x\"], location_df[\"cart_y\"], location_df[\"cart_z\"] = cartesian_coordinates(location_df[\"latitude\"],\n                                                                                            location_df[\"longitude\"])\nlocation_df[\"rho\"], location_df[\"theta\"], location_df[\"phi\"] = cartesian_to_spherical_coordinates(location_df[\"cart_x\"],\n                                                                                                  location_df[\"cart_y\"],\n                                                                                                  location_df[\"cart_z\"])\nlocation_df[\"polar_x\"], location_df[\"polar_y\"], location_df[\"polar_z\"] = polar_coordinates(location_df[\"latitude\"],\n                                                                                           location_df[\"longitude\"])\n\nlocation_df\n\n# Save Output to a New Text File\nlocation_df.to_csv(\"../location_full_coords.txt\", index=False)\n\n","type":"content","url":"/notebooks/foundations/coordinates#add-columns-for-additional-coordinate-types","position":31},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Plot Coordinates"},"type":"lvl2","url":"/notebooks/foundations/coordinates#plot-coordinates","position":32},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Plot Coordinates"},"content":"Coordinates can be hard to visualize internally, so let’s plot them on a world map of Earth. A common plotting tool in Python is matplotlib, but to include a world map we will also use cartopy which stores many different kinds of maps of Earth.\n\n","type":"content","url":"/notebooks/foundations/coordinates#plot-coordinates","position":33},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"World Map","lvl2":"Plot Coordinates"},"type":"lvl3","url":"/notebooks/foundations/coordinates#world-map","position":34},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"World Map","lvl2":"Plot Coordinates"},"content":"To generate a full world map, we need the full range of longitude and latitude from -180 degrees to 180 degrees and -90 degrees to 90 degrees.longitude east = 180\n\nlongitude west = -180\n\nlatitude north = 90\n\nlatitude south = -90\n\n# Setup Matplotlib Plot Figure with a size of 15 by 10\nfig = plt.subplots(figsize=(15, 10)) \n\n# Overlay a plot of the Plate Carree Projection of Earth (a flat map of the planet)\nprojection_map = ccrs.PlateCarree()\nax = plt.axes(projection=projection_map)\n\n# Plot the full range of latitude/longitude\nlon_west, lon_east, lat_south, lat_north = -180, 180, -90, 90\nax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n\n# Include the coastlines (in black) as well as the border of the continents and the states in the US (in grey)\nax.coastlines(color=\"black\")\nax.add_feature(cfeature.BORDERS, edgecolor='grey')\nax.add_feature(cfeature.STATES, edgecolor=\"grey\")\n    \n# Plot each location on the map as a red dot\nlongitudes = location_df[\"longitude\"] # longitude\nlatitudes = location_df[\"latitude\"]   # latitude\nplt.scatter(longitudes, latitudes, c=\"red\")\n\n# Set the title of the map and display\nplt.title(\"World Map with Locations\")\nplt.show()\n\n","type":"content","url":"/notebooks/foundations/coordinates#world-map","position":35},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"United States Map","lvl2":"Plot Coordinates"},"type":"lvl3","url":"/notebooks/foundations/coordinates#united-states-map","position":36},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"United States Map","lvl2":"Plot Coordinates"},"content":"Sometimes you don’t need to view the whole map, but a sub-section. For example, if we only wanted to view the US on a world map we would need a small range of latitude/longtiude coordinateslongitude east = -60\n\nlongitude west = -130\n\nlatitude north = 60\n\nlatitude south = 20\n\n# Setup Matplotlib Plot Figure with a size of 15 by 10\nfig = plt.subplots(figsize=(15, 10)) \n\n# Overlay a plot of the Plate Carree Projection of Earth (a flat map of the planet)\nprojection_map = ccrs.PlateCarree()\nax = plt.axes(projection=projection_map)\n\n# Plot the a range of latitude/longitude to encompass the US\nlon_west, lon_east, lat_south, lat_north = -130, -60, 20, 60\nax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n\n# Include the coastlines (in black) as well as the border of the continents and the states in the US (in grey)\nax.coastlines(color=\"black\")\nax.add_feature(cfeature.BORDERS, edgecolor='grey')\nax.add_feature(cfeature.STATES, edgecolor=\"grey\")\n    \n# Plot each location on the map as a red dot\nlongitudes = location_df[\"longitude\"] # longitude\nlatitudes = location_df[\"latitude\"]   # latitude\nplt.scatter(longitudes, latitudes, c=\"red\")\n\n# Set the title of the map and display\nplt.title(\"United States Map with Locations\")\nplt.show()\n\n\n\n","type":"content","url":"/notebooks/foundations/coordinates#united-states-map","position":37},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/foundations/coordinates#summary","position":38},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Summary"},"content":"Coordinates on the Earth are measured in many different systems: Geodetic (latitude/longitude), Cartesian, Spherical, and Polar. In the next notebooks, these coordinates will be used to create great circle arcs and paths based on vector vector calculations.\n\nIn Python, coordinates can be mapped on to a world map via matplotlib and cartopy.","type":"content","url":"/notebooks/foundations/coordinates#summary","position":39},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/foundations/coordinates#whats-next","position":40},{"hierarchy":{"lvl1":"Coordinate Types","lvl3":"What’s next?","lvl2":"Summary"},"content":"Now that we have coordinates, it’s time to connect them to create great circles!\n\nUp Next: Great Circle arcs and paths\n\n","type":"content","url":"/notebooks/foundations/coordinates#whats-next","position":41},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/foundations/coordinates#resources-and-references","position":42},{"hierarchy":{"lvl1":"Coordinate Types","lvl2":"Resources and references"},"content":"\n\nEd Williams “Avitation Formulary”\n\nMovable Type Scripts","type":"content","url":"/notebooks/foundations/coordinates#resources-and-references","position":43},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"type":"lvl1","url":"/notebooks/how-to-cite","position":0},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"content":"The material in this Project Pythia Cookbook is licensed for free and open consumption and reuse. All code is served under \n\nApache 2.0, while all non-code content is licensed under \n\nCreative Commons BY 4.0 (CC BY 4.0). Effectively, this means you are free to share and adapt this material so long as you give appropriate credit to the Cookbook authors and the Project Pythia community.\n\nThe source code for the book is \n\nreleased on GitHub and archived on Zenodo. This DOI will always resolve to the latest release of the book source:\n\n","type":"content","url":"/notebooks/how-to-cite","position":1},{"hierarchy":{"lvl1":"Great Circle Arcs and Path"},"type":"lvl1","url":"/notebooks/tutorials/arc-path","position":0},{"hierarchy":{"lvl1":"Great Circle Arcs and Path"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/arc-path","position":1},{"hierarchy":{"lvl1":"Great Circle Arcs and Path"},"type":"lvl1","url":"/notebooks/tutorials/arc-path#great-circle-arcs-and-path","position":2},{"hierarchy":{"lvl1":"Great Circle Arcs and Path"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/arc-path#great-circle-arcs-and-path","position":3},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#overview","position":4},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Overview"},"content":"Imagine you are on a plane flying from Cario to Hong Kong. As a passenger, the plane appears to travel a straight path from one airport to the next. However, in reality, as the plane travels it actually curves along the surface of Earth held down by the gravity of the planet.\n\nThe “straight line” has become an arc connecting Cario and Hong Kong on a map. This arc is a great circle arc, just one small subsection of the great circle path.\n\nDistance between Points on a Great Circle Arc\n\nConvert Spherical Distance to Degrees\n\nDetermine the Bearing of a Great Circle Arc\n\nGenerate a Great Circle Arc with Intermediate Points\n\nDetermine the Midpoint of a Great Circle Arc\n\nGenerate a Great Circle Path\n\nDetermine an Antipodal Point\n\n","type":"content","url":"/notebooks/tutorials/arc-path#overview","position":5},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#prerequisites","position":6},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 40 minutes\n\n\n\n","type":"content","url":"/notebooks/tutorials/arc-path#prerequisites","position":7},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#imports","position":8},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Imports"},"content":"To begin, let’s import the packages we will need in this notebook and collect the list of locations coordinates\n\nimport pandas as pd       # reading in data for location information from text file\nimport numpy as np        # working with arrays, vectors, cross/dot products, and radians\n\nfrom pyproj import Geod   # working with the Earth as an ellipsod (WGS-84)\nimport geopy.distance     # working with the Earth as an ellipsod (WGS-84)\n\nimport matplotlib.pyplot as plt    # Plotting a figure\nfrom cartopy import crs as ccrs, feature as cfeature  # Add World Map to Plot\n\n# Get the coordinates for locations with all coordinates\nlocation_df = pd.read_csv(\"../location_full_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df.head()\n\n# Set index to the name column, this will make it easier to access each row\nlocation_df.index = location_df[\"name\"]\nlocation_df.head()\n\n","type":"content","url":"/notebooks/tutorials/arc-path#imports","position":9},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Distance Between Points on a Great Circle Arc"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#distance-between-points-on-a-great-circle-arc","position":10},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Distance Between Points on a Great Circle Arc"},"content":"We can determine the distance between two points A and B (for example, Cario and Hong Kong) both by hand mathematically and with Python packages like pyproj and geopy\n\n","type":"content","url":"/notebooks/tutorials/arc-path#distance-between-points-on-a-great-circle-arc","position":11},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Distance Between Points Mathematically via Unit Sphere","lvl2":"Distance Between Points on a Great Circle Arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#determine-distance-between-points-mathematically-via-unit-sphere","position":12},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Distance Between Points Mathematically via Unit Sphere","lvl2":"Distance Between Points on a Great Circle Arc"},"content":"Unit sphere refers to a sphere with a radius of 1, for the purpose of this cookbook, when we are using a unit sphere to represent Earth, it is a perfect sphere that has been multiplied by 6378137 meters\n\nFirst, to measure the distance between point A (latA, lonA) and point B (latB, lonB) on a unit sphere (radius = 1)d=acos(sin(latA)*sin(latB)+cos(latA)*cos(latB)*cos(lonA-lonB))\n\nBecause of the translation when working with radians and degrees, there is a mathematically equivalent formula that works better when working with shorter distances (to produce less rounding errors):d=2*asin(\\sqrt{sin(\\frac{latA-latB}{2})^2 + cos(latA)*cos(latB)*sin(\\frac{lonA-lonB}{2})^2})\n\nSee more: Distance Between Points\n\nWe can now translate these equations for measuring the distance between two points (the great circle arc distance) into Python and multiply the result by the Earth’s radius.\n\nThese equations use a locations’s latitude/longtiude coordinates, which we can access in a pandas dataframe with the name of the location and which coordinate type we would like, for example:\n\nprint(f\"Boulder latitude: {location_df.loc[\"boulder\", \"latitude\"]}\")\nprint(f\"Boulder longitude: {location_df.loc[\"boulder\", \"longitude\"]}\")\n\nBelow, Equation 1 has become distance_between_points_default since this is the equation we will use for most equations, but Equation 2 has become distance_between_points_small for working with small distances that are less prone to rounding errors. We can call both equations to compare outputs to see how they are mathematically equivalent. By hand, Equation 1 is a faster calculation than Equation 2, but when working with Python both of these functions will run nearly as quickly.\n\ndef distance_between_points_default(start_point=None, end_point=None):\n    earth_radius = 6378137  # meters\n    latA = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lonA = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    latB = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    lonB = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n\n    distance_default = np.arccos(np.sin(latA)*np.sin(latB)+np.cos(latA)*np.cos(latB)*np.cos(lonA-lonB))\n    return distance_default * earth_radius\n\ndef distance_between_points_small(start_point=None, end_point=None):\n    earth_radius = 6378137  # meters\n    latA = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lonA = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    latB = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    lonB = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n\n    distance_small = 2 * np.arcsin(np.sqrt((np.sin((latA-latB)/2))**2 + np.cos(latA)*np.cos(latB)*(np.sin((lonA-lonB)/2))**2))\n    return distance_small * earth_radius\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-distance-between-points-mathematically-via-unit-sphere","position":13},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Sidenote: Additional Formulas","lvl2":"Distance Between Points on a Great Circle Arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#sidenote-additional-formulas","position":14},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Sidenote: Additional Formulas","lvl2":"Distance Between Points on a Great Circle Arc"},"content":"While we will be focusing on Equation 1 and Equation 2 for our calculations in the future, there are even more methods to calculate the distance between points on a sphere. Each formula has different degrees of precision based on which ellipsoid or sphere is used:\n\nHaversine Formula\n\nVincenty’s Formula\n\nMeeus Great Circle Distance\n\nLaw of Cosines Great Circle Distance\n\n","type":"content","url":"/notebooks/tutorials/arc-path#sidenote-additional-formulas","position":15},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Distance Points via Python Package pyproj","lvl2":"Distance Between Points on a Great Circle Arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#determine-distance-points-via-python-package-pyproj","position":16},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Distance Points via Python Package pyproj","lvl2":"Distance Between Points on a Great Circle Arc"},"content":"While great circle distances can be determine mathematically, there are some Python packages that account for the fact that the Earth is not a perfect sphere that will be easier to work than relying entirely on the equations derived above. For example, pyproj treats the Earth as an ellipsoid, by default specifically WGS-84.\n\nWGS-84 is the World Geodetic System and considered to be the current standard for geodesy and working with satellite. It is an geocentric and is consistent to within 1 meter around the globe.\n\nTo begin, let use use pyproj to set up an ellipsoid (WGS-84) that will represent the Earth.\n\ndef distance_pyproj(start_pt=None, end_pt=None):\n    geodesic = Geod(ellps=\"WGS84\") # setup ellipsoid\n\n    # Return the distance between two points (for example, Boulder and Boston)\n    _, _, distance_meter =  geodesic.inv(location_df.loc[start_pt, \"longitude\"],\n                                         location_df.loc[start_pt, \"latitude\"],\n                                         location_df.loc[end_pt, \"longitude\"],\n                                         location_df.loc[end_pt, \"latitude\"])\n    \n    return distance_meter\n\n# Find the distance between Boulder and Boston\ndistance_meter = distance_pyproj(\"boulder\", \"boston\")\nprint(f\"Distance between coordinates (ellipsoid)   = {distance_meter/1000} km\")\n\nThat is much easier! We can compare pyproj to the output from the equations (1 and 2) that we calculated above:\n\ndistance_unit_sphere_default = distance_between_points_default(\"boulder\", \"boston\")\nprint(f\"Distance between coordinates (unit sphere) = {distance_unit_sphere_default/1000} km\")\ndistance_unit_sphere_small = distance_between_points_small(\"boulder\", \"boston\")\nprint(f\"Distance between coordinates (unit sphere) = {distance_unit_sphere_small/1000} km\")\n\nBoth equations we calculated above slightly underestimate the distance between Boston and Boulder because they assume the Earth is a perfect sphere, pyproj accounts for ellipse.\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-distance-points-via-python-package-pyproj","position":17},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Convert Spherical Distance to Degrees"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#convert-spherical-distance-to-degrees","position":18},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Convert Spherical Distance to Degrees"},"content":"Sometimes when you are working with a map, you don’t always just need a distance in meters or kilometers. We can also convert the distances calculated back into degrees as needed. To convert a distance from meters to degrees, we will assume that the great circle is on a unit sphere with a constant spherical radius of ~6371 km (mean radius of Earth).\n\nSide note: The Python library ObsPy has a similar function built-in: \n\nObsPy kilometer2degrees()\n\nearth_radius = 6378.137 # km\n\ndef km_to_degree_distance(distance_km=None):\n    return distance_km / (2 * earth_radius * np.pi / 360)\n\ndef degree_to_km_distance(distance_degree=None):\n    return distance_degree * (2 * earth_radius * np.pi / 360)\n\n# We can convert back and form between kilometers and degrees\nprint(f\"300 km to degrees = {km_to_degree_distance(300)} degrees\")\nprint(f\"2.6949458523585643 degree to km = {degree_to_km_distance(2.6949458523585643)} km\")\n\n","type":"content","url":"/notebooks/tutorials/arc-path#convert-spherical-distance-to-degrees","position":19},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Determine the Bearing of a Great Circle Arc"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#determine-the-bearing-of-a-great-circle-arc","position":20},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Determine the Bearing of a Great Circle Arc"},"content":"Arcs are not just a distance, but a direction. Now, we can calculate the direction that an arc takes as it moves from Point A to Point B also known as the bearing.\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-the-bearing-of-a-great-circle-arc","position":21},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine the Bearing Mathematically via Unit Sphere","lvl2":"Determine the Bearing of a Great Circle Arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#determine-the-bearing-mathematically-via-unit-sphere","position":22},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine the Bearing Mathematically via Unit Sphere","lvl2":"Determine the Bearing of a Great Circle Arc"},"content":"The bearing between between Point A (latA, lonA) and Point B (latB, lonB) on a unit sphere can be calculated as:x = cos(latA) * sin(latB) - sin(latA) * cos(latB) * cos(lonB - lonA)y = sin(lonB - lonA) * cos(latB)θ = atan2(y, x)\n\nMovable Type: Bearing\n\nThis can be similarly converted to Python as:\n\ndef bearing_between_points_unit_sphere(start_point=None, end_point=None):\n    latA = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lonA = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    latB = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    lonB = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n\n    x = np.cos(latA) * np.sin(latB) - np.sin(latA) * np.cos(latB) * np.cos(lonB - lonA)\n    y = np.sin(lonB - lonA) * np.cos(latB)\n    bearing = np.arctan2(y, x)\n    return np.rad2deg(bearing) % 360\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-the-bearing-mathematically-via-unit-sphere","position":23},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine the Bearing via Python Package pyproj","lvl2":"Determine the Bearing of a Great Circle Arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#determine-the-bearing-via-python-package-pyproj","position":24},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine the Bearing via Python Package pyproj","lvl2":"Determine the Bearing of a Great Circle Arc"},"content":"pyproj can also use the same geodesic.inv() function to calculate bearing. However, pyproj includes both the forward and reverse bearing. Forward bearing refers to the bearing from Point A to Point B, while the reverse bearing is the bearing from Point B to Point A. The reverse bearing is returned as a negative angle, but it can also be calculated as the Forward Bearing - 360.\n\nFor example, to find the bearing from Boulder and Boston:\n\ngeodesic = Geod(ellps=\"WGS84\")\nfwd_bearing, rvs_bearing, _ =  geodesic.inv(location_df.loc[\"boulder\", \"longitude\"],\n                                             location_df.loc[\"boulder\", \"latitude\"],\n                                             location_df.loc[\"boston\", \"longitude\"],\n                                             location_df.loc[\"boston\", \"latitude\"])\nprint(f\"Forward Bearing: {fwd_bearing}\")\nprint(f\"Reverse Bearing: {rvs_bearing} ({rvs_bearing%360})\")\n\nWhen referring to bearing however, it is typically assumed to be referring to the forward bearing, so we will use the function below as we move forward.\n\ndef bearing_between_points_ellps(start_point=None, end_point=None):\n    geodesic = Geod(ellps=\"WGS84\")\n    fwd_bearing, _, _ =  geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                        location_df.loc[start_point, \"latitude\"],\n                                        location_df.loc[end_point, \"longitude\"],\n                                        location_df.loc[end_point, \"latitude\"])\n    return fwd_bearing\n\nBecause of the slightly flattened shape of an ellipsoid compared to a sphere, the bearing can also vary depending on if you are calculating bearing on a unit sphere or a ellipsoid:\n\n### Compare Unit Sphere and Ellipsoid\nbeaing_ellps = bearing_between_points_ellps(\"boulder\", \"boston\")\nprint(f\"forward bearing between coordinates (ellipsoid)   = {beaing_ellps} Degrees\")\nbearing_us = bearing_between_points_unit_sphere(\"boulder\", \"boston\")\nprint(f\"forward bearing between coordinates (unit sphere) = {bearing_us} Degrees\")\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-the-bearing-via-python-package-pyproj","position":25},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#generating-a-great-circle-arc-with-intermediates-points","position":26},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"Now we have calculated both the length of a great circle arc as well as its bearing. Now we can begin to add additional points along the arc. These intermediate points will lie along the great circle arc and can be calculated as the fractional distance laong the arc (for example, a point for every 10th of the arc).\n\n","type":"content","url":"/notebooks/tutorials/arc-path#generating-a-great-circle-arc-with-intermediates-points","position":27},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Intermediate Points Mathemetically via Unit Sphere (Fractional Distance)","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#determine-intermediate-points-mathemetically-via-unit-sphere-fractional-distance","position":28},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Intermediate Points Mathemetically via Unit Sphere (Fractional Distance)","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"Along a unit sphere, we can calculate each intermediate point as a fractional distance along the arc. We can determine the points as a given fraction of a distance (d) between a starting points A (latA, lonA) and the final point B (latB, lonB) where f is a fraction along the great circle arc. As a result, Point A is atf=0 and Point B sits atf=1 along the arc.\n\nNote: The points must not lie on exact opposite sides of a sphere (antipodal), otherwise, the path is undefined because f=0=1\n\nWhere, antipodal is defined by:latA + latB = 0\n\nabs(lonA - lonB) = pi\n\nWhere the distance between two points is the angular distance:d = \\frac{\\text{total distance of arc}}{\\text{earth's radius}}\n\nThe intermediate points (lat, lon) along a given path starting point to end point:A = sin(\\frac{(1-f) * d}{sin(d)}B = \\frac{sin(f*d)}{sin(d)}x = A * cos(latA) * cos(lonA) + B * cos(latB) * cos(lonB)y = A * cos(latA) * sin(lonA) + B * cos(latB) * sin(lonB)z = A * sin(latA) + B * sin(latB)lat = atan2(z, \\sqrt{x^2 + y^2})lon = atan2(y, x)\n\nEd Williams: Intermediate Points on a Great Circle\n\nMoveable Type: Intermediate Point\n\nLet’s translate this math into Python code:\n\ndef intermediate_points(start_point=None, end_point=None,\n                        fraction=None, distance=None):\n    # Calculates the position of an intermediate point based on its fractional position along an arc defined from Point A to Point B\n    earth_radius = 6378137  # meters\n    total_distance = distance / earth_radius\n    latA = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lonA = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    latB = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    lonB = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n\n    A = np.sin((1-fraction) * total_distance) / np.sin(total_distance)\n    B = np.sin(fraction * total_distance) / np.sin(total_distance)\n    x = (A * np.cos(latA) * np.cos(lonA)) + (B * np.cos(latB) * np.cos(lonB))\n    y = (A * np.cos(latA) * np.sin(lonA)) + (B * np.cos(latB) * np.sin(lonB))\n    z = (A * np.sin(latA)) + (B * np.sin(latB))\n    lat = np.arctan2(z, np.sqrt(x**2 + y**2))\n    lon = np.arctan2(y, x)\n    return (float(np.rad2deg(lat)), float(np.rad2deg(lon)))\n\ndef calculate_intermediate_pts(start_point=None, end_point=None,\n                               fraction=None, total_distance_meter=None):\n    # returns a list of intermediate points along the arc separated by a specific fraction\n    fractions = np.arange(0, 1+fraction, fraction)\n    intermediate_lat_lon = []\n    for fractional in fractions:\n        intermediate_pts = intermediate_points(start_point, end_point,\n                                                fractional, total_distance_meter)\n        intermediate_lat_lon.append(intermediate_pts)\n    return intermediate_lat_lon\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-intermediate-points-mathemetically-via-unit-sphere-fractional-distance","position":29},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Intermediate Points via Python Package pyproj and geopy","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#determine-intermediate-points-via-python-package-pyproj-and-geopy","position":30},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Determine Intermediate Points via Python Package pyproj and geopy","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"However, there is a strong advantage when you the Python libraries pyproj and geopy. Not only can you use an ellipsoid instead of a sphere, you can also interpolate points along an arc in additional ways:\n\nA fractional distance laong the arc (for example, a point for every 10th of the arc)\n\nA known distance along the arc (for example, a point ever 100 meters)\n\nAn equal amount of points (for example, adding 6 intermediate points which are equally spaced along the arc)\n\nBelow you will see how we can use one function interpolate_points_along_gc to be able to solve for all three possible types of intermediate points. The function will use both the starting and ending coordinates (Point A to Point B) and a distance you’d like to have between each point.\n\ndef interpolate_points_along_gc(lat_start,\n                                lon_start,\n                                lat_end,\n                                lon_end,\n                                distance_between_points_meter): \n    # Interpolate intermediate points along an arc with a given distance between each point\n    lat_lon_points = [(float(lat_start), float(lon_start))]\n    \n    # move to next point when distance between points is less than the equal distance\n    move_to_next_point = True\n    while(move_to_next_point):\n        forward_bearing, _, distance_meters = geodesic.inv(lon_start,\n                                                            lat_start, \n                                                            lon_end,\n                                                            lat_end)\n        if distance_meters < distance_between_points_meter:\n            # ends before overshooting\n            move_to_next_point = False\n        else:\n            start_point = geopy.Point(lat_start, lon_start)\n            distance_to_move = geopy.distance.distance(\n                            kilometers=distance_between_points_meter /\n                            1000)  # distance to move towards the next point\n            final_position = distance_to_move.destination(\n                            start_point, bearing=forward_bearing)\n            lat_lon_points.append((float(final_position.latitude), float(final_position.longitude)))\n            # new starting position is newly found end position\n            lon_start, lat_start = final_position.longitude, final_position.latitude\n    lat_lon_points.append((float(lat_end), float(lon_end)))\n    return lat_lon_points\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-intermediate-points-via-python-package-pyproj-and-geopy","position":31},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Interpolate with N Total Equally Spaced Points","lvl3":"Determine Intermediate Points via Python Package pyproj and geopy","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl4","url":"/notebooks/tutorials/arc-path#interpolate-with-n-total-equally-spaced-points","position":32},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Interpolate with N Total Equally Spaced Points","lvl3":"Determine Intermediate Points via Python Package pyproj and geopy","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"Imagine we are flying a plane with a set amount of gas and will need to make 10 stops along our path to refuel from Boulder to Boston. If we need to stop 10 times (imagine that there is a refueling station wherever we stop) then we can interpolate along our path with 10 additional points\n\nn_total_points = 10 # total points (n points)\n\n# Calculate the distance between Point A (Boulder) and Point B (Boston)\ndistance_meter = distance_pyproj(\"boulder\", \"boston\")\nprint(f\"Total distance from Boulder to Boston = {distance_meter/1000} km\")\n\ndistance_between_points_meter = distance_meter / (n_total_points + 1)\nprint(f\"Each of the {n_total_points} points will be separated by {distance_between_points_meter} meters ({distance_between_points_meter/1000} km)\")\n\nExcellent! Now that we know the distances between each of the 10 equally spaced points we can use interpolate_points_along_gc to find a list of interpolated points. Note that will be 12 total points, 10 intermediate points and 1 for each the starting and ending position.\n\nlat_start, lon_start = location_df.loc[[\"boulder\"]][\"latitude\"].iloc[0], location_df.loc[[\"boulder\"]][\"longitude\"].iloc[0]\nlat_end, lon_end = location_df.loc[[\"boston\"]][\"latitude\"].iloc[0], location_df.loc[[\"boston\"]][\"longitude\"].iloc[0]\n\ninterpolated_pts = interpolate_points_along_gc(lat_start,\n                                          lon_start,\n                                          lat_end,\n                                          lon_end,\n                                          distance_between_points_meter)\nprint(f\"{len(interpolated_pts)} Total Points\")\nprint(f\"List of Interpolated Points:\\n{interpolated_pts}\")\n\n","type":"content","url":"/notebooks/tutorials/arc-path#interpolate-with-n-total-equally-spaced-points","position":33},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#plot-arcs-as-points-on-a-world-map","position":34},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"The easiest way to understand how these interpolated points will look along an arc is to plot them. To be able to reuse this plotting structure in multiple examples below we will encompass the plot into a simple function which takes in a string for the plot’s title and a list of coordinates (which will include Point A at the start and Point B at the end)\n\ndef plot_coordinate(lst_of_coords=None, title=None):\n    # Set up world map plot on the United States\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    lon_west, lon_east, lat_south, lat_north = -130, -60, 20, 60\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n    \n    # Plot Latitude/Longitude Coordinates\n    longitudes = [x[1] for x in lst_of_coords] # longitude\n    latitudes = [x[0] for x in lst_of_coords] # latitude\n    plt.plot(longitudes, latitudes)\n    plt.scatter(longitudes, latitudes)\n    \n    # Setup Axis Limits and Title/Labels\n    plt.title(title)\n    plt.show()\n\nNow, let’s plot those 10 equally spaced points!\n\nplot_coordinate(interpolated_pts,\n                title=f\"Interpolate {n_total_points} Equally Spaced Points\")\n\nLooking good! Alright, let’s move along to interpolate based on a known distance\n\n","type":"content","url":"/notebooks/tutorials/arc-path#plot-arcs-as-points-on-a-world-map","position":35},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Interpolate every N meters","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl4","url":"/notebooks/tutorials/arc-path#interpolate-every-n-meters","position":36},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Interpolate every N meters","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"A plane has a fuel tank that can hold a known amount of gas, what if instead we wanted to known how far we need to refuel, but now in meters? Let’s say we hold a gas tank that can hold enough fuel to get 112 km, how many times will we need to stop and where along would those stops appear?\n\ndistance_between_points_meter = 112000 # 122.0 km\nprint(f\"Each point will be separated by {distance_between_points_meter} meters ({distance_between_points_meter/1000} km)\")\n\nlat_start, lon_start = location_df.loc[\"boulder\", \"latitude\"], location_df.loc[\"boulder\", \"longitude\"]\nlat_end, lon_end = location_df.loc[\"boston\", \"latitude\"], location_df.loc[\"boston\", \"longitude\"]\n\ninterpolated_pts = interpolate_points_along_gc(lat_start,\n                                          lon_start,\n                                          lat_end,\n                                          lon_end,\n                                          distance_between_points_meter)\nprint(f\"{len(interpolated_pts)} Total Points\")\nprint(f\"List of Interpolated Points:\\n{interpolated_pts}\")\n\nplot_coordinate(interpolated_pts,\n                title=f\"Interpolate every {distance_between_points_meter/1000} km\")\n\nThat’s a lot of stop! Ok, now we can return to a familiar system. We can use this same system to also determine fractional distances as well!\n\n","type":"content","url":"/notebooks/tutorials/arc-path#interpolate-every-n-meters","position":37},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Interpolate a fractional distance along arc","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"type":"lvl4","url":"/notebooks/tutorials/arc-path#interpolate-a-fractional-distance-along-arc","position":38},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Interpolate a fractional distance along arc","lvl3":"Plot Arcs as Points on a World Map","lvl2":"Generating a Great Circle Arc with Intermediates Points"},"content":"Above we calculated how to find intermediate points as a fractional distance along an arc. We can now return to this, but with the advantages of using an ellipsoid! Let’s try this method and interpolate points every 10th of an arc.\n\nfraction = 1/10\n\ndistance_between_points_meter = fraction * distance_meter\nprint(f\"Interpolate for every {fraction} of the arc\")\nprint(f\"Each point will be separated by {distance_between_points_meter} meters ({distance_between_points_meter/1000} km)\")\n\nlat_start, lon_start = location_df.loc[\"boulder\", \"latitude\"], location_df.loc[\"boulder\", \"longitude\"]\nlat_end, lon_end = location_df.loc[\"boston\", \"latitude\"], location_df.loc[\"boston\", \"longitude\"]\n\ninterpolated_pts = interpolate_points_along_gc(lat_start,\n                                          lon_start,\n                                          lat_end,\n                                          lon_end,\n                                          distance_between_points_meter)\nprint(f\"{len(interpolated_pts)} Total Points\")\nprint(f\"List of Interpolated Points:\\n{interpolated_pts}\")\n\nplot_coordinate(interpolated_pts,\n                title=f\"(Ellipsoid) Interpolate every {fraction}th of the arc\")\n\nWe can now compare both the ellipsoid and spherical model. First, let’s plot the same fractional distance along the unit sphere:\n\ndistance_unit_sphere_default = distance_between_points_default(\"boulder\", \"boston\")\nintermediate_unit_sphere = calculate_intermediate_pts(\"boulder\", \"boston\",\n                                               fraction, distance_unit_sphere_default)\nprint(f\"{len(intermediate_unit_sphere)} Total Points\")\nprint(f\"List of Interpolated Points:\\n{intermediate_unit_sphere}\")\n\nplot_coordinate(intermediate_unit_sphere,\n                title=f\"(Unit Sphere) Interpolate every {fraction}th of the arc\")\n\nThe difference between the ellipsoid and the sphere will become more apparently as intermediate points along the arc are shifted to new positions based on whether or not it is a sphere.\n\n# Compare Unit Sphere and Ellipsoid\nfor i in range(len(interpolated_pts)):\n    _, _, distance_m = geodesic.inv(interpolated_pts[i][0], interpolated_pts[i][1],\n                                   intermediate_unit_sphere[i][0], intermediate_unit_sphere[i][1])\n    if np.isnan(distance_m): distance_m = 0\n    print(f\"Difference in distance between ellipsoid/unit sphere at point {i}: {distance_m} meters\")\n\n","type":"content","url":"/notebooks/tutorials/arc-path#interpolate-a-fractional-distance-along-arc","position":39},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Determine the Midpoint of a Great Circle Arc"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#determine-the-midpoint-of-a-great-circle-arc","position":40},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Determine the Midpoint of a Great Circle Arc"},"content":"The advantage of using fractional distances it is make it simple to find the midpoint along the arc. The midpoint of an arc can be determined as a fractional distance along an arc where f = 0.5.\n\ndistance_meter = distance_pyproj(\"boulder\", \"boston\")\n\n# Distance along the arc where the midpoint lies:\nmidpoint = distance_meter / 2\n\nlat_start, lon_start = location_df.loc[\"boulder\", \"latitude\"], location_df.loc[\"boulder\", \"longitude\"]\nlat_end, lon_end = location_df.loc[\"boston\", \"latitude\"], location_df.loc[\"boston\", \"longitude\"]\n\nintermediate_geodesic = interpolate_points_along_gc(lat_start,\n                                          lon_start,\n                                          lat_end,\n                                          lon_end,\n                                          midpoint)\nprint(f\"{len(interpolated_pts)} Total Points\")\nprint(f\"List of Interpolated Points:\\n{interpolated_pts}\")\nprint(f\"Midpoint = {interpolated_pts[1]}\")\n\nOk, let’s compare the midpoint along the ellipsoid and the unit sphere:\n\ndistance_unit_sphere_default = distance_between_points_default(\"boulder\", \"boston\")\nintermediate_unit_sphere = calculate_intermediate_pts(\"boulder\", \"boston\",\n                                               1/2, distance_unit_sphere_default)\nprint(f\"{len(intermediate_unit_sphere)} Total Points\")\nprint(intermediate_unit_sphere)\nprint(f\"Midpoint = {intermediate_geodesic[1]}\")\n\n# Compare geodesic and unit sphere\n_, _, distance_m = geodesic.inv(intermediate_geodesic[1][0], intermediate_geodesic[1][1],\n                                   intermediate_unit_sphere[1][0], intermediate_unit_sphere[1][1])\nprint(f\"Distance between unit sphere and ellipsoid's midpoints = {distance_m} meters\")\n\n132 meters isn’t very far when you are working with something as large as the Earth, but that is more than an entire football field away from each other!\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-the-midpoint-of-a-great-circle-arc","position":41},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Generate a Great Circle Path"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#generate-a-great-circle-path","position":42},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Generate a Great Circle Path"},"content":"A great circle arc is the arc formed between two points along the surface of a sphere. So far, this is all we’ve focused on. However, imagine if you extending that arc in the same bearing all the way around the globe until you returned back to your starting position. This is known as a great circle path.\n\nThe great circle path can be used to determine where (at what latitude/longtiude) a great circle would cross a given parallel as well as illustrate how the plane cutting through the globe that is used to form a great circle.\n\nBecause a great circle path will move from -180 degrees to 180 degrees longitude, then all we need to know is what the latitude at each point would be. A a valid great circle path only exists if:\n\nPoint A and Point B are not meridians (at the same longitude, directly above or below each other)\n\nPoint A and Point B are not Antipodal (exactly on opposite sides of the globe)\n\nOtherwise, the great circle path is considered undefined.\n\nTo do this, we will generate a list of longitude points from -180 to 180 degrees. By default, this will be 360 total points, 1 point for each degree longitude. Then, since we know the starting and ending point, we can determine the latitude for any longitude point (lon) along the great circle path generated from a great circle arc (from Point A to Point B):\\text{latitude} = atan(\\frac{sin(latA)*cos(latB)*sin(lon-lonB)-sin(latB)*cos(latA)*sin(lon-lon1)}{cos(latA)*cos(latB)*sin(lonA-lonB)})\n\nSee more: Latitude of point on GC\n\n# Find Latitude Coordinate based on a Longitude Coordinate and a Great Circle Arc formed by Point A (start) to Point B (end)\ndef generate_latitude_along_gc(start_point=None, end_point=None, number_of_lon_pts=360):\n    # Generate a list of latitude coordinates for the great circle path\n\n    # First convert each point to radians (to work with sin/cos)\n    lat1 = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lon1 = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    lat2 = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    lon2 = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n\n    # Verify not meridian (longitude passes through the poles)\n    # If points lie at the same longitude, alert user and return a totally linear path\n    if np.sin(lon1 - lon2) == 0:\n        print(\"Invalid inputs: start/end points are meridians\")\n        # plotting meridians at 0 longitude through all latitudes\n        meridian_lat = np.arange(-90, 90, 180/len(longitude_lst)) # split in n number\n        meridians = []\n        for lat in meridian_lat:\n            meridians.append((lat, 0))\n        return meridians\n\n    # verify not antipodal (diametrically opposite points)\n    if lat1 + lat2 == 0 and abs(lon1-lon2) == np.pi:\n        # if points are anitpodal, alert user and return empty list\n        print(\"Invalid inputs: start/end points are antipodal\")\n        return []\n\n    # generate N total number of longitude points along the great circle\n    # Similar code in R: https://github.com/rspatial/geosphere/blob/master/R/greatCircle.R#L18C3-L18C7\n    gc_lon_lst = []\n    for lon in range(1, number_of_lon_pts+1):\n        new_lon = (lon  * (360/number_of_lon_pts) - 180)\n        gc_lon_lst.append(np.deg2rad(new_lon))\n\n    # Intermediate points on a great circle: https://edwilliams.org/avform147.htm#Int\n    # Equation 22\n    gc_lat_lon = []\n    for gc_lon in gc_lon_lst:\n        num = np.sin(lat1)*np.cos(lat2)*np.sin(gc_lon-lon2)-np.sin(lat2)*np.cos(lat1)*np.sin(gc_lon-lon1)\n        den = np.cos(lat1)*np.cos(lat2)*np.sin(lon1-lon2)\n        new_lat = np.arctan(num/den)\n        # convert back to degrees and save latitude/longitude pair\n        gc_lat_lon.append((np.rad2deg(new_lat), np.rad2deg(gc_lon)))\n    return gc_lat_lon\n\nNow we have a great circle arc (formed from Point A to Point B) and a list of possible longitude values (from -180 to 180 degrees). With generate_latitude_along_gc we can generate a full list of latitude/longitude pairs for the entire great circle path!\n\nTo plot both the great circle arc and the great circle path, we will use arc_points to get a list of the great circle arc positions and generate_latitude_along_gc to get a list of the points along the great circle path. There will be obvious overlap for the small section of the path that contains the arc.\n\ndef arc_points(start_lat=None,\n               start_lon=None,\n               end_lat=None,\n               end_lon=None,\n               n_total_points=10):\n    _, _, distance_meter =  geodesic.inv(start_lon,\n                                        start_lat,\n                                        end_lon,\n                                        end_lat)\n        \n    distance_between_points_meter = distance_meter / (n_total_points + 1)\n\n    \n    points_along_arc = interpolate_points_along_gc(start_lat,\n                                              start_lon,\n                                              end_lat,\n                                              end_lon,\n                                              distance_between_points_meter)\n    return points_along_arc\n\nTime to plot! To keep it simple plot_coordinates will take in a list of points along the great circle path with a starting and ending point (Point A and B) and internally generate a list of points for the great circle arc.\n\ndef plot_coordinate(lat_lon_lst=None,\n                    start_point=None, end_point=None,\n                    title=None):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    lon_west, lon_east, lat_south, lat_north = -180, 180, -90, 90\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.BORDERS, edgecolor='grey')\n    ax.add_feature(cfeature.STATES, edgecolor=\"grey\")\n        \n    # Get list of points along the great circle path (in blue)\n    longitudes = [x[1] for x in lat_lon_lst] # longitude\n    latitudes = [x[0] for x in lat_lon_lst] # latitude\n    plt.plot(longitudes, latitudes, c=\"cornflowerblue\")\n    plt.scatter(longitudes, latitudes, c=\"cornflowerblue\")\n\n    # Generate a great circle arc from the starting to ending point (in red)\n    start_end_lat_lon = arc_points(location_df.loc[start_point, \"latitude\"],\n                                   location_df.loc[start_point, \"longitude\"],\n                                   location_df.loc[end_point, \"latitude\"],\n                                   location_df.loc[end_point, \"longitude\"],\n                                   n_total_points=20)\n    longitudes = [x[1] for x in start_end_lat_lon] # longitude\n    latitudes = [x[0] for x in start_end_lat_lon] # latitude\n    plt.plot(longitudes, latitudes, c=\"red\")\n    plt.scatter(longitudes, latitudes, c=\"red\")\n    \n    # Setup Axis Limits and Title/Labels\n    plt.title(title)\n    plt.show()\n\nLet’s see how this look! First, let’s see how the great circle path and arc from Boulder to Boston looks:\n\nstart_pt = \"boulder\"\nend_pt = \"boston\"\nn_pts = 360 # number of points along the longitude (resolution for 360 is one point for each 1 degree)\nlat_lon_pts = generate_latitude_along_gc(start_pt, end_pt, number_of_lon_pts=n_pts)\nplot_coordinate(lat_lon_pts, start_pt, end_pt,\n                f\"Plot Great Circle, made from the arc {start_pt.title()} to {end_pt.title()}\")\n\nHow about a longer arc? Let’s start at the Arceibo Telescope and move up to Greenwich (the Prime Meridian)\n\nstart_pt = \"arecibo\"\nend_pt = \"greenwich\"\nn_pts = 360 # number of points along the longitude (resolution for 360 is one point for each 1 degree)\nlat_lon_pts = generate_latitude_along_gc(start_pt, end_pt, number_of_lon_pts=n_pts)\nplot_coordinate(lat_lon_pts, start_pt, end_pt,\n                f\"Plot Great Circle, made from the arc {start_pt.title()} to {end_pt.title()}\")\n\nExcellent! And now a very extreme example, starting all the way down in Zambezi and all the way up to Svalbard\n\nstart_pt = \"zambezi\"\nend_pt = \"svalbard\"\nn_pts = 360\nlat_lon_pts = generate_latitude_along_gc(start_pt, end_pt, number_of_lon_pts=n_pts)\nplot_coordinate(lat_lon_pts, start_pt, end_pt,\n                f\"Plot Great Circle, made from the arc {start_pt.title()} to {end_pt.title()}\")\n\n","type":"content","url":"/notebooks/tutorials/arc-path#generate-a-great-circle-path","position":43},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Wait! Wasn’t a Great Circle Suppose to be a Line?","lvl2":"Generate a Great Circle Path"},"type":"lvl4","url":"/notebooks/tutorials/arc-path#wait-wasnt-a-great-circle-suppose-to-be-a-line","position":44},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl4":"Wait! Wasn’t a Great Circle Suppose to be a Line?","lvl2":"Generate a Great Circle Path"},"content":"You are right! Great circle paths will appear like a straight line that cuts the globe in half. However, on a flat projection, a perfectly straight path will appear curved.\n\n","type":"content","url":"/notebooks/tutorials/arc-path#wait-wasnt-a-great-circle-suppose-to-be-a-line","position":45},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Determine an Antipodal Point"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#determine-an-antipodal-point","position":46},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Determine an Antipodal Point"},"content":"Imagine you could directly down below your feet through the Earth and all the way to the otherside of the planet. Where would that be? This exactly opposite position is known as a antipodal point.\n\nThe latitude is simple, it is simply the inverse of your current latitude. So, standing at 40 degrees in Boulder, my antipodal latitude will sit at -40 degrees, we can defined this as:\\text{antipodal latitude} = -1 * \\text{latitude}\n\nAntipodal longitude is a little more complicated. This will depend on if you are standing to the East (positive) or West (negative) of the Prime Meridian (0 degrees longitude)\\text{anitpodal longitude} = (\\text{longitude} + 180) \\text{ if longitude} \\le 0\\text{anitpodal longitude} = (\\text{longitude} - 180) \\text{ if longitude} \\gt 0\n\ndef antipodal(start_point=None):\n    # return the antipodal (latitude/longitude) point from a starting position\n    anti_lat = -1 * location_df.loc[start_point, \"latitude\"]\n    ref_lon = location_df.loc[start_point, \"longitude\"]\n    if ref_lon > 0:\n        anti_lon = ref_lon - 180\n    else:\n        anti_lon = ref_lon + 180\n    return (float(anti_lat), float(anti_lon))\n\ndef is_antipodal(start_point=None, end_point=None):\n    # return true is a point is antipodal from another point\n    lon1 = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    lat1 = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lon2 = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n    lat2 = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    return lat1 + lat2 == 0 and abs(lon1-lon2) == np.pi\n\nSee for yourself on this antipodes map, but we can also plot this in Python.\n\ndef plot_antipodal(start_point=None):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    lon_west, lon_east, lat_south, lat_north = -180, 180, -90, 90\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.BORDERS, edgecolor='grey')\n    ax.add_feature(cfeature.STATES, edgecolor=\"grey\")\n        \n    # Plot Start point (in blue)\n    plt.scatter(location_df.loc[start_point, \"longitude\"],\n                location_df.loc[start_point, \"latitude\"],\n                s=100, c=\"cornflowerblue\", label=start_point.title())\n\n    # Plot Antipodal Point (in red)\n    antipodal_point = antipodal(start_point)\n    plt.scatter(antipodal_point[1], antipodal_point[0], s=100, c=\"red\", label=\"Antipodal\")\n    \n    # Setup Axis Limits and Title/Labels\n    plt.title(f\"{start_point.title()} and Antipodal Point {antipodal_point}\")\n    plt.legend(loc=\"lower right\")\n    plt.show()\n\nLet’s see how this looks. Where does the antipodal point from Boulder lie?\n\nplot_antipodal(\"boulder\")\n\nAh, the middle of the ocean. What about Svalbard?\n\nplot_antipodal(\"svalbard\")\n\nJust off the coast of Antartica! And the city of Cairo?\n\nplot_antipodal(\"cairo\")\n\nWe are back in the ocean, but that isn’t strange. The Earth is mostly water, so don’t be surprised if the point on the opposite of the globe from you is lying in the middle of the ocean.\n\n\n\n","type":"content","url":"/notebooks/tutorials/arc-path#determine-an-antipodal-point","position":47},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#summary","position":48},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Summary"},"content":"This notebook covered how to generate and plot great circle arcs and paths with just a starting and ending position. This also included how to calculate the bearing of a great circle arc as well interpolating along the great circle and even how to find the antipodal point to any point on the globe. You were able to see how the difference between treating the Earth as a sphere or as an ellipsoid impacts the final precision.","type":"content","url":"/notebooks/tutorials/arc-path#summary","position":49},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/tutorials/arc-path#whats-next","position":50},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl3":"What’s next?","lvl2":"Summary"},"content":"With a great circle arc defined, it’s time to start using the great circle arc as part of a large question. Next, we will determine if a third point is along the arc or at what distance it sits from the great circle arc and path.\n\n","type":"content","url":"/notebooks/tutorials/arc-path#whats-next","position":51},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/tutorials/arc-path#resources-and-references","position":52},{"hierarchy":{"lvl1":"Great Circle Arcs and Path","lvl2":"Resources and references"},"content":"\n\nEd Williams “Avitation Formulary”\n\nMovable Type Scripts","type":"content","url":"/notebooks/tutorials/arc-path#resources-and-references","position":53},{"hierarchy":{"lvl1":"Great Circles and a Point"},"type":"lvl1","url":"/notebooks/tutorials/arc-to-point","position":0},{"hierarchy":{"lvl1":"Great Circles and a Point"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point","position":1},{"hierarchy":{"lvl1":"Great Circles and a Point"},"type":"lvl1","url":"/notebooks/tutorials/arc-to-point#great-circles-and-a-point","position":2},{"hierarchy":{"lvl1":"Great Circles and a Point"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#great-circles-and-a-point","position":3},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#overview","position":4},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Overview"},"content":"Oh no! A plane traveling across the country suddenly discovers it is low on fuel! It can no longer make it to the planned airport, instead it has to find the closest airport to its current position that it can make it with its remaining fuel.\n\nIn great circle terms, we want to determine how far a point (let’s say, the next closest airport) is from a great circle arc (the flight’s path). In this notebook we will:\n\nDetermine the distance of a point to a great circle arc (cross-track and along-track distance)\n\nDetermine if a point lies on a great circle arc and path (with and without tolerances)\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#overview","position":5},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#prerequisites","position":6},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 20 minutes\n\n\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#prerequisites","position":7},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#imports","position":8},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Imports"},"content":"Import Packages\n\nSetup location dataframe with coordinates\n\nimport pandas as pd                                    # read in data text file\nimport numpy as np                                     # working with degrees and radians\n\nfrom pyproj import Geod                                # working with the Earth as an ellipsod (WGS-84)\nimport geopy.distance                                  # moving along a known distance on the Earth's ellipsoid surface\n\nimport matplotlib.pyplot as plt                        # plotting a graph\nfrom cartopy import crs as ccrs, feature as cfeature   # plotting a world map\n\n# Get all Coordinates for Locations\nlocation_df = pd.read_csv(\"../location_full_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df.index = location_df[\"name\"]\nlocation_df.head()\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#imports","position":9},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Determine the distance of a point to a great circle arc"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#determine-the-distance-of-a-point-to-a-great-circle-arc","position":10},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Determine the distance of a point to a great circle arc"},"content":"The distance from a point to a great circle arc is known as the cross track distance (sometimes known as cross track error). For example, how far would a plane have to fly from its path to get to an unscheduled airport for refueling? Meantime, the along track distance measures how far along the great arc a point lies. For instance, what is your new position (latitude/longitude) when you’ve traveled 250 km into your 2000 km plane ride?\n\nCross track distance: angular distance from point P to great circle path\n\nAlong track distance: angular distance along the great circle path from A to B before hitting a point that is closest to point P\n\ngeodesic = Geod(ellps=\"WGS84\")\nearth_radius = 6378137  # meters\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#determine-the-distance-of-a-point-to-a-great-circle-arc","position":11},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"Cross Track Distance","lvl2":"Determine the distance of a point to a great circle arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-to-point#cross-track-distance","position":12},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"Cross Track Distance","lvl2":"Determine the distance of a point to a great circle arc"},"content":"Distance of a point to a great circle arc is defined as:dxt = asin( sin(δ13) ⋅ sin(θ13 − θ12) ) * R\n\nWhere,\n\nδ13 (delta_13) is (angular) distance from start point to third point\n\nθ13 (theta_13) is (initial) bearing from start point to third point\n\nθ12 (theta_12) is (initial) bearing from start point to end point\n\nR is the earth’s radius\n\nThen,d_xt = np.arcsin(np.sin(delta_13)*np.sin(theta_13 - theta_12)) * RXTD =asin(sin(dist_AD)*sin(crs_AD-crs_AB))\n\nWhere,\n\nPositive Cross-Track Distance: Point lies in the hemisphere to the left of the great circle\n\nNegative Cross-Track Distance: Point lies in the hemiphere to the right of the great circle\n\nNote: If the point A is the North or South Pole replace crs_AD-crs_AB with\nlon_D-lon_B or lon_B-lon_D, respectively\n\nSee more: Cross track error\n\nThat was a lot of math, let’s see how that translates into a Python function. For the purpose of this example, let’s determine the forward bearing and distance between the great circle arc and the new point on an ellipsoid.\n\nWe will be creating two sides of a spherical triangle. Side 1 will be the great circle arc formed from Point A to Point B, while Side 2 will be a new great circle arc we will create from Point A to the new point C. We can use the angle—angular distance—between these two legs to determine the cross track distance:\n\ndef cross_track_distance(start_point=None, end_point=None, new_point=None):\n    # Determine the forward bearing from Point A (start) to Point B (end)\n    fwd_bearing_start_end, _, _ = geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                               location_df.loc[start_point, \"latitude\"],\n                                               location_df.loc[end_point, \"longitude\"],\n                                               location_df.loc[end_point, \"latitude\"])\n    \n    # Determine the forward bearing (angle) and distance from Point A (start) to new Point C\n    fwd_bearing_start_new, _, distance_m_start_new = geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                                                  location_df.loc[start_point, \"latitude\"],\n                                                                  location_df.loc[new_point, \"longitude\"],\n                                                                  location_df.loc[new_point, \"latitude\"]) \n\n    # Determine the Angular Distance from Point A to Point C\n    angular_distance_start_new = distance_m_start_new / earth_radius\n    ct_distance = np.arcsin(np.sin(angular_distance_start_new) * np.sin(np.deg2rad(fwd_bearing_start_new - fwd_bearing_start_end))) * earth_radius\n    return ct_distance\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#cross-track-distance","position":13},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"Along Track Distance","lvl2":"Determine the distance of a point to a great circle arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-to-point#along-track-distance","position":14},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"Along Track Distance","lvl2":"Determine the distance of a point to a great circle arc"},"content":"Imagine a great circle arc that will appear like: A -------- C -------------------B, where the distance along the great circle arc (created from Point A to B) from Point A to Point C is the along-track distance.\n\nThis is defined as:dat = acos(\\frac{cos(δ13)}{cos(δxt)}) * R\n\nδ13 (delta_13) is (angular) distance from start point to third point\n\nδxt (delta_xt) is (angular) cross-track distance\n\nR is the earth’s radius\n\nSo,d_at = np.arccos(\\frac{np.cos(delta_13)}{np.cos(d_xt/R)} * RATD=acos(\\frac{cos(dist_AD)}{cos(XTD)})\n\nHowever, for very short distances we can also use a new equation that is less susceptible to rounding errors:ATD=asin(\\sqrt{\\frac{sin(dist_AD))^2 - (sin(XTD))^2 )}{cos(XTD)}}\n\nSee more: Along track distance\n\nTo similarly convert into a Python function, we will need to know the total length of the great circle arc from Point A to Point B. We will also measure the distance from the Point A to the new Point C along the great circle arc from Point A to Point B.\n\ndef along_track_distance(start_point=None, end_point=None, new_point=None):\n    # Determine the cross track distance from Point A to Point B from Point C\n    crosst_distance = cross_track_distance(start_point, end_point, new_point)\n\n    # Determine the total distance of a great circle arc from Point A to Point C\n    _, _, distance_m_start_new = geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                              location_df.loc[start_point, \"latitude\"],\n                                              location_df.loc[new_point, \"longitude\"],\n                                              location_df.loc[new_point, \"latitude\"])  \n    \n    # Determine the Along-Track Distance using the Cross Track Distance Distance \n    angular_distance_start_new = distance_m_start_new / earth_radius\n    at_distance = np.arccos(np.cos(angular_distance_start_new) / np.cos(crosst_distance / earth_radius)) * earth_radius\n    return at_distance\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#along-track-distance","position":15},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"Determine Closest Point along Great Circle Arc","lvl2":"Determine the distance of a point to a great circle arc"},"type":"lvl3","url":"/notebooks/tutorials/arc-to-point#determine-closest-point-along-great-circle-arc","position":16},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"Determine Closest Point along Great Circle Arc","lvl2":"Determine the distance of a point to a great circle arc"},"content":"To be able to plot a cross track distance we need to find the point on the great circle that is closest to the new Point C. To do this we need to find the closest point from Point C to the arc and measure the along track distance that the intersection lies\n\n# Distance point along great circle path\ndef point_along_path(start_point=None, end_point=None, distance_m=None):\n    fwd_bearing, _, _ = geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                     location_df.loc[start_point, \"latitude\"],\n                                     location_df.loc[end_point, \"longitude\"],\n                                     location_df.loc[end_point, \"latitude\"])  \n    origin = geopy.Point(location_df.loc[start_point, \"latitude\"],\n                         location_df.loc[start_point, \"longitude\"])\n    distance_to_move = geopy.distance.distance(\n                            kilometers=distance_m / 1000)  # distance to move towards the next point\n    final_position = distance_to_move.destination(origin, bearing=fwd_bearing)\n    return (final_position.latitude, final_position.longitude)\n\nLet’s see how of this looks on a map! Let’s plot!\n\nIn the previous notebook, we determined how to interpolate points along the great circle arc (interpolate_points_along_gc and arc_points). We will repeat the functions below to be able to use them to plot the great circle arc with the new information about cross-track and along-track distances\n\n# See Previous Notebook for how these functions were defined\n\ndef interpolate_points_along_gc(lat_start,\n                                lon_start,\n                                lat_end,\n                                lon_end,\n                                distance_between_points_meter): \n    lat_lon_points = [(lat_start, lon_start)]\n    \n    # move to next point when distance between points is less than the equal distance\n    move_to_next_point = True\n    while(move_to_next_point):\n        forward_bearing, reverse_bearing, distance_meters = geodesic.inv(lon_start,\n                                                                         lat_start, \n                                                                         lon_end,\n                                                                         lat_end)\n        if distance_meters < distance_between_points_meter:\n            # ends before overshooting\n            move_to_next_point = False\n        else:\n            start_point = geopy.Point(lat_start, lon_start)\n            distance_to_move = geopy.distance.distance(\n                            kilometers=distance_between_points_meter /\n                            1000)  # distance to move towards the next point\n            final_position = distance_to_move.destination(\n                            start_point, bearing=forward_bearing)\n            lat_lon_points.append((final_position.latitude, final_position.longitude))\n            # new starting position is newly found end position\n            lon_start, lat_start = final_position.longitude, final_position.latitude\n    lat_lon_points.append((lat_end, lon_end))\n    return lat_lon_points\n\ndef arc_points(start_lat=None,\n               start_lon=None,\n               end_lat=None,\n               end_lon=None,\n               n_total_points=10):\n    _, _, distance_meter =  geodesic.inv(start_lon,\n                                        start_lat,\n                                        end_lon,\n                                        end_lat)\n        \n    distance_between_points_meter = distance_meter / (n_total_points + 1)\n\n    \n    new_points_lst = interpolate_points_along_gc(start_lat,\n                                              start_lon,\n                                              end_lat,\n                                              end_lon,\n                                              distance_between_points_meter)\n    return new_points_lst\n\nTo begin, we will plot the cross track distance. This will look like a map with two arcs: one from Point A to Point B (the primary great circle arc) and a second that will show the angular distance between the great circle arc and a new point\n\ndef plot_cross_track(start_point=None, end_point=None, new_point=None,\n                     lon_west=-130, lon_east=-60,\n                     lat_south=20, lat_north=60):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(16, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.BORDERS, edgecolor='grey')\n    ax.add_feature(cfeature.STATES, edgecolor=\"grey\")\n\n    # Cross-Track and Along-Track Distances\n    ct_distance = cross_track_distance(start_point, end_point, new_point)\n    print(f\"Cross Track Distance: \\n{ct_distance} meters ({ct_distance/1000} km)\")\n\n    at_distance = along_track_distance(start_point, end_point, new_point)\n    print(f\"Along Track Distance: \\n{at_distance} meters ({at_distance/1000} km)\\n\")\n\n    closest_point = point_along_path(start_point, end_point, at_distance)\n    print(f\"Closest Point To Point Along Great Circle Path:\\n{closest_point}\") \n\n    # Plot Latitude/Longitude Points of the Great Circle Arc (with 10 interpolate points)\n    great_circle_arc_pts = arc_points(location_df.loc[start_point, \"latitude\"],\n                                      location_df.loc[start_point, \"longitude\"],\n                                      location_df.loc[end_point, \"latitude\"],\n                                      location_df.loc[end_point, \"longitude\"],\n                                      10)\n    longitudes = [x[1] for x in great_circle_arc_pts] # longitude\n    latitudes = [x[0] for x in great_circle_arc_pts] # latitude\n    plt.plot(longitudes, latitudes, c=\"purple\")\n    plt.scatter(longitudes, latitudes, c=\"purple\")\n\n    # Plot the Cross Track Distance as an Arc from Point C to the closest point on the arc (Point D) (with 10 intrpolated points)\n    cross_track_arc = arc_points(closest_point[0],\n                                 closest_point[1],\n                                 location_df.loc[new_point, \"latitude\"],\n                                 location_df.loc[new_point, \"longitude\"],\n                                   10)\n    longitudes = [x[1] for x in cross_track_arc] # longitude\n    latitudes = [x[0] for x in cross_track_arc] # latitude\n    plt.plot(longitudes, latitudes, c=\"green\")\n    plt.scatter(longitudes, latitudes, c=\"green\")\n\n    # Plot the Closest Point on the Arc in Red (to see easier)\n    plt.scatter(closest_point[1], closest_point[0], c=\"red\")\n\n    plt.title(f\"Closest Point {closest_point} from {start_point.title()}->{end_point.title()} to {new_point.title()}, Cross-Track Distance = {ct_distance/1000:4f} km\")\n    plt.show()\n\nPositive Cross-Track Distance: Point lies in the hemisphere to the left of the great circle\n\nNegative Cross-Track Distance: Point lies in the hemiphere to the right of the great circle\n\nplot_cross_track(start_point=\"boulder\", end_point=\"boston\", new_point=\"cape canaveral\")\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#determine-closest-point-along-great-circle-arc","position":17},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Determine if a point lies on a great circle arc and path"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#determine-if-a-point-lies-on-a-great-circle-arc-and-path","position":18},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Determine if a point lies on a great circle arc and path"},"content":"Does a given Point C lie on a great circle arc? Does it lie on the great circle path? We can check if a point lies on a great circle path/arc if:\n\nCheck if the latitude/longtiude matches the expected latitude that the same longitude position would have produced on the great circle path\n\nThis is possible with and without tolerances (in meters) to allow for some grace based on your precision.\n\ndef is_point_on_arc(start_point=None, end_point=None,\n                check_point=None, tolerance=0):\n    # tolerance in meters\n    lon1 = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    lat1 = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lon2 = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n    lat2 = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n    check_lon = np.deg2rad(location_df.loc[check_point, \"longitude\"])\n    check_lat = np.deg2rad(location_df.loc[check_point, \"latitude\"])\n\n    # Verify not meridian (longitude passes through the poles)\n    if np.sin(lon1 - lon2) == 0:\n        print(\"Invalid inputs: start/end points are meridians\")\n        return np.nan\n    \n    # verify not antipodal (diametrically opposite, points)\n    if lat1 + lat2 == 0 and abs(lon1-lon2) == np.pi:\n        print(\"Invalid inputs: start/end points are antipodal\")\n        return np.nan\n\n    # account for tolerance based on cross-track distance from arc\n    ct_distance = cross_track_distance(start_point, end_point, check_point)\n    print(f\"Cross-Track Distance = {ct_distance} meters\")\n    if np.abs(ct_distance) <= tolerance:\n        return True\n\n    # determine expected latitude\n    num = np.sin(lat1)*np.cos(lat2)*np.sin(check_lon-lon2)-np.sin(lat2)*np.cos(lat1)*np.sin(check_lon-lon1)\n    den = np.cos(lat1)*np.cos(lat2)*np.sin(lon1-lon2)\n    new_lat = np.arctan(num/den)\n    expected_lat = np.rad2deg(new_lat)\n    return bool(check_lat == expected_lat)\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#determine-if-a-point-lies-on-a-great-circle-arc-and-path","position":19},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl4":"Check if a point lies on a great circle arc","lvl2":"Determine if a point lies on a great circle arc and path"},"type":"lvl4","url":"/notebooks/tutorials/arc-to-point#check-if-a-point-lies-on-a-great-circle-arc","position":20},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl4":"Check if a point lies on a great circle arc","lvl2":"Determine if a point lies on a great circle arc and path"},"content":"Let’s see this for ourselves. Does the city of Rockford lie on the great circle arc from Boulder to Boston?\n\nis_point_on_arc(\"boulder\", \"boston\", \"rockford\", tolerance=0) # with no tolerance (0 meters)\n\nRockford is sitting about 18 km away from the great circle arc that is formed by Boulder and Boston. Let’s give it a look on a map:\n\nplot_cross_track(start_point=\"boulder\", end_point=\"boston\", new_point=\"rockford\")\n\nHard to see, right? Let’s zoom in:\n\nplot_cross_track(start_point=\"boulder\", end_point=\"boston\", new_point=\"rockford\", \n                 lon_west=-95, lon_east=-85,\n                 lat_south=40, lat_north=45)\n\n18 km is far, but for the sake of clarity, maybe it serves our purposes as “on the arc”. If so, we can increase the tolerance of the function to about 18 km to encompass the town:\n\n# increase tolerance to capture point\nprint(\"tolerance = 0\")\nprint(is_point_on_arc(\"boulder\", \"boston\", \"rockford\", tolerance=0))\nprint(\"\\ntolerance >= cross-track distance\")\nprint(is_point_on_arc(\"boulder\", \"boston\", \"rockford\", tolerance=18202))\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#check-if-a-point-lies-on-a-great-circle-arc","position":21},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"(Optional) Additional Python Package: UXarray","lvl2":"Determine if a point lies on a great circle arc and path"},"type":"lvl3","url":"/notebooks/tutorials/arc-to-point#id-optional-additional-python-package-uxarray","position":22},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"(Optional) Additional Python Package: UXarray","lvl2":"Determine if a point lies on a great circle arc and path"},"content":"UXarray acts as an Xarray extension for unstructured data (commonly used in climate and weather analysis). This includes multiple functions for working with \n\ngreat circles:\n\nuxarray.grid.intersections.gca_const_lat_intersection: Calculate the intersection point(s) of a Great Circle Arc (GCA) and a constant latitude line in a Cartesian coordinate system\n\ngrid.arcs.point_within_gca: Check if a point lies on a given Great Circle Arc (GCA) interval, considering the smaller arc of the circle. Handles the anti-meridian case as well\n\nuxarray.grid.arcs.extreme_gca_latitude: Calculate the maximum or minimum latitude of a great circle arc defined by two 3D points\n\nUXarray makes use of Cartesian coordinates and includes a very narrow built-in tolerance, but can be a simple solution if needed.\n\nFor example: Let’s check if a point lies on a great circle arc with UXarray (\n\nsee example)\n\n# Check if Boulder is on a great circle arc created by a point directly above (+latitude) and below (-latitude)\n\n# Convert latitude and longitude points to Cartesian Points\ndef latlon_to_cart(lat, lon):\n    from astropy.coordinates.representation import UnitSphericalRepresentation\n    from astropy import units\n\n    spherical_coords = UnitSphericalRepresentation(\n        lat=lat * units.deg, lon=lon * units.deg\n    )\n    cart_coords = spherical_coords.to_cartesian()\n    return np.array([cart_coords.x, cart_coords.y, cart_coords.z])\n\n\npt_within = latlon_to_cart(location_df.loc[\"boulder\", \"latitude\"], location_df.loc[\"boulder\", \"longitude\"]) # Boulder\nvertex_a = latlon_to_cart(location_df.loc[\"boulder\", \"latitude\"]+10, location_df.loc[\"boulder\", \"longitude\"])  # Point exactly 10 degrees above Boulder\nvertex_b = latlon_to_cart(location_df.loc[\"boulder\", \"latitude\"]-10, location_df.loc[\"boulder\", \"longitude\"])  # Point exactly 10 degrees below Boulder\n\n# Determine if point lies along great circle arc\nfrom uxarray.grid.arcs import point_within_gca\n\nprint(\n    f\"Boulder lies within the great circle arc = {point_within_gca(pt_within, vertex_a, vertex_b)}\"\n)\n\n\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#id-optional-additional-python-package-uxarray","position":23},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#summary","position":24},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Summary"},"content":"In this notebook, we calculated and plotted the cross track and along track distance for points around a great circle arc","type":"content","url":"/notebooks/tutorials/arc-to-point#summary","position":25},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/tutorials/arc-to-point#whats-next","position":26},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl3":"What’s next?","lvl2":"Summary"},"content":"Next, we will determine when a great circle path crosses a given parallel and the maximum and minimum latitude coordinates of a great circle path.\n\n","type":"content","url":"/notebooks/tutorials/arc-to-point#whats-next","position":27},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/tutorials/arc-to-point#resources-and-references","position":28},{"hierarchy":{"lvl1":"Great Circles and a Point","lvl2":"Resources and references"},"content":"\n\nAviation Formulary V1.47\n\nMoveable Type Script","type":"content","url":"/notebooks/tutorials/arc-to-point#resources-and-references","position":29},{"hierarchy":{"lvl1":"Great Circles and Parallels"},"type":"lvl1","url":"/notebooks/tutorials/parallels-max-min","position":0},{"hierarchy":{"lvl1":"Great Circles and Parallels"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min","position":1},{"hierarchy":{"lvl1":"Great Circles and Parallels"},"type":"lvl1","url":"/notebooks/tutorials/parallels-max-min#great-circles-and-parallels","position":2},{"hierarchy":{"lvl1":"Great Circles and Parallels"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#great-circles-and-parallels","position":3},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#overview","position":4},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Overview"},"content":"As a great circle path traverses around the globe, it will eventually hit a maximum or minimum latitude (unless it is a great circlea around the equator which will never vary in latitude). For this notebook, we will learn how to determine the position for the maximum and minimum positions along the globe as well as how to determine where (and if) a point crosses a specific parallel.\n\nDetermine the maximum latitude on a great circle path\n\nDetermine the minimum latitude on a great circle path\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#overview","position":5},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#prerequisites","position":6},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 30 minutes\n\n\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#prerequisites","position":7},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#imports","position":8},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Imports"},"content":"Import Packages\n\nSetup location dataframe with coordinates\n\nimport pandas as pd       # reading in data for location information from text file\nimport numpy as np        # working with arrays, vectors, cross/dot products, and radians\n\nfrom pyproj import Geod   # working with the Earth as an ellipsod (WGS-84)\n\nimport matplotlib.pyplot as plt                        # plotting a graph\nfrom cartopy import crs as ccrs, feature as cfeature   # plotting a world map\n\n# Get all Coordinates for Locations\nlocation_df = pd.read_csv(\"../location_full_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df.head()\n\nlocation_df.index = location_df[\"name\"]\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#imports","position":9},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Maximum Latitude on a Great Circle Path"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#maximum-latitude-on-a-great-circle-path","position":10},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Maximum Latitude on a Great Circle Path"},"content":"\n\nWe have previously determined an equation to derive a great circle path from intermediate points from two points on a great circle arc. Without additional calculations, we can use a list of points along the great circle path to find the maximum location of the maximum and minimum. It will simply be when the latitude is either at its maximum and minimum.\n\nBy default, the equation below will determine 360 points along longitude, so the output will only have a resolution of 1 degree. However, by defining the longitude with more points, the resolution increases.\n\n# See Previous Notebook to see how we generate a list of latitude/longtiude points for a great circle path\n\ndef generate_latitude_along_gc(start_point=None, end_point=None, number_of_lon_pts=360):\n    lon1 = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    lat1 = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lon2 = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n    lat2 = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n\n    # Verify not meridian (longitude passes through the poles)\n    if np.sin(lon1 - lon2) == 0:\n        print(\"Invalid inputs: start/end points are meridians\")\n        # plotting meridians at 0 longitude through all latitudes\n        meridian_lat = np.arange(-90, 90, 180/len(longitude_lst)) # split in n number\n        meridians = []\n        for lat in meridian_lat:\n            meridians.append((lat, 0))\n        return meridians\n\n    # verify not anitpodal (diametrically opposite, points)\n    if lat1 + lat2 == 0 and abs(lon1-lon2) == np.pi:\n        print(\"Invalid inputs: start/end points are antipodal\")\n        return []\n\n    # generate n total number of longitude points along the great circle\n    # https://github.com/rspatial/geosphere/blob/master/R/greatCircle.R#L18C3-L18C7\n    gc_lon_lst = []\n    for lon in range(1, number_of_lon_pts+1):\n        new_lon = (lon  * (360/number_of_lon_pts) - 180)\n        gc_lon_lst.append(np.deg2rad(new_lon))\n\n    # Intermediate points on a great circle: https://edwilliams.org/avform147.htm\"\n    gc_lat_lon = []\n    for gc_lon in gc_lon_lst:\n        num = np.sin(lat1)*np.cos(lat2)*np.sin(gc_lon-lon2)-np.sin(lat2)*np.cos(lat1)*np.sin(gc_lon-lon1)\n        den = np.cos(lat1)*np.cos(lat2)*np.sin(lon1-lon2)\n        new_lat = np.arctan(num/den)\n        gc_lat_lon.append((float(np.rad2deg(new_lat)), float(np.rad2deg(gc_lon))))\n    return gc_lat_lon\n\n# A Point Every Degree\nlat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=360)\nprint(f\"Max Latitude Position (within 1 degree): {max(lat_lon, key=lambda x:x[0])}\")\n\n# A Point Every Half a Degree\nlat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=720)\nprint(f\"Max Latitude Position (within 0.5 degree): {max(lat_lon, key=lambda x:x[0])}\")\n\n# A Point Every Third of a Degree\nlat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=1080)\nprint(f\"Max Latitude Position (within 0.3 degree): {max(lat_lon, key=lambda x:x[0])}\")\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#maximum-latitude-on-a-great-circle-path","position":11},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Plot Maximum","lvl2":"Maximum Latitude on a Great Circle Path"},"type":"lvl3","url":"/notebooks/tutorials/parallels-max-min#plot-maximum","position":12},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Plot Maximum","lvl2":"Maximum Latitude on a Great Circle Path"},"content":"Let’s see this on a map. Let’s plot the maximum point along a great circle path:\n\ndef plot_coordinate_max_min(great_circle_pts=None,\n                            max_coord=None, min_coord=None,\n                            title=None):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    lon_west, lon_east, lat_south, lat_north = -180, 180, -90, 90\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n    \n    # Plot Great Circle Latitude/Longitude Locations\n    longitudes = [x[1] for x in great_circle_pts] # longitude\n    latitudes = [x[0] for x in great_circle_pts] # latitude\n    plt.plot(longitudes, latitudes)\n\n    # Overly Max/Min Coordinates in red and green\n    if max_coord is not None:\n        plt.scatter([max_coord[1]], [max_coord[0]], s=100, c=\"red\")\n    if min_coord is not None:\n        plt.scatter([min_coord[1]], [min_coord[0]], s=100, c=\"green\")\n    \n    # Setup Axis Limits and Title/Labels\n    plt.title(title)\n    plt.show()\n\ngc_lat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=360)\nmax_lat_lon = max(gc_lat_lon, key=lambda x:x[0])\nplot_coordinate_max_min(great_circle_pts=gc_lat_lon,\n                            max_coord=max_lat_lon,\n                            title=f\"Max Latitude located at {max_lat_lon}\")\n\ngc_lat_lon = generate_latitude_along_gc(\"boulder\", \"houston\", number_of_lon_pts=360)\nmax_lat_lon = max(gc_lat_lon, key=lambda x:x[0])\nplot_coordinate_max_min(great_circle_pts=gc_lat_lon,\n                            max_coord=max_lat_lon,\n                            title=f\"Max Latitude located at {max_lat_lon}\")\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#plot-maximum","position":13},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Maximumn Latitude from Clairaut’s Formula","lvl2":"Maximum Latitude on a Great Circle Path"},"type":"lvl3","url":"/notebooks/tutorials/parallels-max-min#maximumn-latitude-from-clairauts-formula","position":14},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Maximumn Latitude from Clairaut’s Formula","lvl2":"Maximum Latitude on a Great Circle Path"},"content":"Clairaut’s Formula (Clairaut’s equation or Clairaut’s relation) is a differential equation which defines the relationship between the latitude, φ, and the true course (bearing, θ) where:sin(θ) * cos(φ) = \\text{constant}\n\nFor any two points (A and B) along the great circle:sin(θA) * cos(φA) = sin(θB) * cos(φB)\n\nAt the maximum latitude, the true course must be at 90 and 270, where for any bearing/latitude along the great circle:\\text{max latitude} = acos(|sin(θ) * cos(φ)|)\n\nFor the purpose of this example, we will use pyproj geodesic to determine the bearing based on a great circle arc, but consult previous sections if you want to determine the bearing mathetically based on the unit sphere instead of the ellipsoid.\n\nImportant\n\nClairaut’s Formula assumes the globe as a unit sphere with equal radius, and as a result, it is subject to errors (about 3%).\n\nEd Williams: Clairaut’s Formula\n\ndef clairaut_formula_max(start_point=None, end_point=None):\n    geodesic = Geod(ellps=\"WGS84\")\n    fwd_bearing, _, _ =  geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                      location_df.loc[start_point, \"latitude\"],\n                                      location_df.loc[end_point, \"longitude\"],\n                                      location_df.loc[end_point, \"latitude\"])\n    # Clairaut\n    start_lat = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    max_lat = np.arccos(np.abs(np.sin(fwd_bearing) * np.cos(start_lat)))\n    return np.rad2deg(max_lat)\n\nmax_lat = clairaut_formula_max(\"boulder\", \"boston\")\nprint(f\"Max latitude from Boulder to Boston: {max_lat}\")\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#maximumn-latitude-from-clairauts-formula","position":15},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Minimum Latitude on a Great Circle Path"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#minimum-latitude-on-a-great-circle-path","position":16},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Minimum Latitude on a Great Circle Path"},"content":"Like finding maximum from a list of great circle path, the smallest latitude can be found by analysing the list for the smallest latitude point. The minimum also represents the antipodal position on the globe from the maximum.\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#minimum-latitude-on-a-great-circle-path","position":17},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Antipodal Point of Max is the Minimum","lvl2":"Minimum Latitude on a Great Circle Path"},"type":"lvl3","url":"/notebooks/tutorials/parallels-max-min#antipodal-point-of-max-is-the-minimum","position":18},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Antipodal Point of Max is the Minimum","lvl2":"Minimum Latitude on a Great Circle Path"},"content":"\n\ndef antipodal(latitude=None, longitude=None):\n    anti_lat = -1 * latitude\n    if longitude > 0:\n        anti_lon = longitude - 180\n    else:\n        anti_lon = longitude + 180\n    return (anti_lat, anti_lon)\n\ngc_lat_lon = generate_latitude_along_gc(\"boulder\", \"houston\", number_of_lon_pts=360)\nmax_lat_lon = max(gc_lat_lon, key=lambda x:x[0])\nprint(f\"Maximum Position: {max_lat_lon}\")\nprint(f\"Minimum (Antipodal) Position : {antipodal(max_lat_lon[0], max_lat_lon[1])}\")\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#antipodal-point-of-max-is-the-minimum","position":19},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Minimum Latitude along Great Circle Path","lvl2":"Minimum Latitude on a Great Circle Path"},"type":"lvl3","url":"/notebooks/tutorials/parallels-max-min#minimum-latitude-along-great-circle-path","position":20},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Minimum Latitude along Great Circle Path","lvl2":"Minimum Latitude on a Great Circle Path"},"content":"\n\nlat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=360)\nprint(f\"Min Latitude (within 1 degree): {min(lat_lon, key=lambda x:x[0])}\")\n\nlat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=720)\nprint(f\"Min Latitude (within 0.5 degree): {min(lat_lon, key=lambda x:x[0])}\")\n\nlat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=1080)\nprint(f\"Min Latitude (within 0.3 degree): {min(lat_lon, key=lambda x:x[0])}\")\n\nLet’s give it a look:\n\ngc_lat_lon = generate_latitude_along_gc(\"boulder\", \"boston\", number_of_lon_pts=360)\nmin_lat_lon = min(gc_lat_lon, key=lambda x:x[0])\nplot_coordinate_max_min(great_circle_pts=gc_lat_lon,\n                            min_coord=min_lat_lon,\n                            title=f\"Min Latitude located at {min_lat_lon}\")\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#minimum-latitude-along-great-circle-path","position":21},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Maximumn Latitude from Clairaut’s Formula","lvl2":"Minimum Latitude on a Great Circle Path"},"type":"lvl3","url":"/notebooks/tutorials/parallels-max-min#maximumn-latitude-from-clairauts-formula-1","position":22},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"Maximumn Latitude from Clairaut’s Formula","lvl2":"Minimum Latitude on a Great Circle Path"},"content":"To solve for the minimum latitude, the true course should be when 0 and 180 degrees where for any bearing/latitude along the great circle:\\text{min latitude} = asin(|sin(θ) * cos(φ)|)\n\nThe southernmost (min) point is the antipodal to the northernmost (max) latitude.\n\ndef clairaut_formula_min(start_point=None, end_point=None):\n    geodesic = Geod(ellps=\"WGS84\")\n    fwd_bearing, _, _ =  geodesic.inv(location_df.loc[start_point, \"longitude\"],\n                                      location_df.loc[start_point, \"latitude\"],\n                                      location_df.loc[end_point, \"longitude\"],\n                                      location_df.loc[end_point, \"latitude\"])\n    # Clairaut Formula\n    start_lat = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    min_lat = np.arcsin(np.abs(np.cos(fwd_bearing) * np.sin(start_lat)))\n    return np.rad2deg(min_lat)\n\nmin_lat = clairaut_formula_min(\"boulder\", \"boston\")\nprint(f\"Min latitude along great circle path from Boulder to Boston: {min_lat}\")\n\n\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#maximumn-latitude-from-clairauts-formula-1","position":23},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#summary","position":24},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Summary"},"content":"In this notebook, we determined the position and coordinates for the maximum and minimum positions along the great circle arc.","type":"content","url":"/notebooks/tutorials/parallels-max-min#summary","position":25},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/tutorials/parallels-max-min#whats-next","position":26},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl3":"What’s next?","lvl2":"Summary"},"content":"Next, we will work with multiple great circle paths to determine how and where they interact.\n\n","type":"content","url":"/notebooks/tutorials/parallels-max-min#whats-next","position":27},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/tutorials/parallels-max-min#resources-and-references","position":28},{"hierarchy":{"lvl1":"Great Circles and Parallels","lvl2":"Resources and references"},"content":"\n\nAviation Formulary V1.47\n\nMoveable Type Script","type":"content","url":"/notebooks/tutorials/parallels-max-min#resources-and-references","position":29},{"hierarchy":{"lvl1":"Intersections of Great Circles"},"type":"lvl1","url":"/notebooks/tutorials/path-intersection","position":0},{"hierarchy":{"lvl1":"Intersections of Great Circles"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/path-intersection","position":1},{"hierarchy":{"lvl1":"Intersections of Great Circles"},"type":"lvl1","url":"/notebooks/tutorials/path-intersection#intersections-of-great-circles","position":2},{"hierarchy":{"lvl1":"Intersections of Great Circles"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#intersections-of-great-circles","position":3},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#overview","position":4},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Overview"},"content":"A great circle path crosses the entire planet and as a result, any two (valid) great circle paths will always intersect at exactly two points around the globe.\n\nIn this notebook, we will:\n\nFind the intersection of two great circle paths\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#overview","position":5},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#prerequisites","position":6},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 30 minutes\n\n\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#prerequisites","position":7},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#imports","position":8},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Imports"},"content":"Import Packages\n\nSetup location dataframe with coordinates\n\nimport pandas as pd       # reading in data for location information from text file\nimport numpy as np        # working with arrays, vectors, cross/dot products, and radians\n\nfrom pyproj import Geod   # working with the Earth as an ellipsod (WGS-84)\nimport geopy.distance     # working with the Earth as an ellipsod\n\nimport matplotlib.pyplot as plt                        # plotting a graph\nfrom cartopy import crs as ccrs, feature as cfeature   # plotting a world map\n\n# Get all Coordinates for Locations\nlocation_df = pd.read_csv(\"../location_full_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df.head()\n\nlocation_df.index = location_df[\"name\"]\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#imports","position":9},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Find the intersection of two great circle paths"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#find-the-intersection-of-two-great-circle-paths","position":10},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Find the intersection of two great circle paths"},"content":"The intersection of two great circle paths always exists at two positions on the globe.\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#find-the-intersection-of-two-great-circle-paths","position":11},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl3":"Math of intersection","lvl2":"Find the intersection of two great circle paths"},"type":"lvl3","url":"/notebooks/tutorials/path-intersection#math-of-intersection","position":12},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl3":"Math of intersection","lvl2":"Find the intersection of two great circle paths"},"content":"We can determine the intersections of two great circle paths as a the normal of two planes containing the great circles. Where the two planes intersect will represent the intersections on the surface of the globe.\n\nFirst, we find the cross product of the vectors for the position’s cartesian coordinates. Then, we find the cross product of the two normal planes. This will result in two intersection points, one for each side of the planet.\n\nSee more: Intersecting Radials\n\ndef intersection_of_gc(start_gc1=None, end_gc1=None,\n                      start_gc2=None, end_gc2=None):\n    # determine the normal of planes containing great circles\n\n    # cross product of vectors\n    normal_one = np.cross([location_df.loc[start_gc1, \"cart_x\"],\n                           location_df.loc[start_gc1, \"cart_y\"],\n                           location_df.loc[start_gc1, \"cart_z\"]],\n                          [location_df.loc[end_gc1, \"cart_x\"],\n                           location_df.loc[end_gc1, \"cart_y\"],\n                           location_df.loc[end_gc1, \"cart_z\"]])\n    normal_two = np.cross([location_df.loc[start_gc2, \"cart_x\"],\n                           location_df.loc[start_gc2, \"cart_y\"],\n                           location_df.loc[start_gc2, \"cart_z\"]],\n                          [location_df.loc[end_gc2, \"cart_x\"],\n                           location_df.loc[end_gc2, \"cart_y\"],\n                           location_df.loc[end_gc2, \"cart_z\"]])\n\n    # intersection of planes, normal to the poles of each plane\n    line_of_intersection = np.cross(normal_one, normal_two)\n\n    # intersection points (one on each side of the earth)\n    x1 = line_of_intersection /  np.sqrt(line_of_intersection[0]**2 + line_of_intersection[1]**2 + line_of_intersection[2]**2) \n    x2 = -x1\n    lat1 = np.rad2deg(np.arctan2(x1[2], np.sqrt(pow(x1[0],2)+pow(x1[1],2))))\n    lon1 = np.rad2deg(np.arctan2(x1[1], x1[0]))\n    lat2 = np.rad2deg(np.arctan2(x2[2], np.sqrt(pow(x2[0],2)+pow(x2[1],2))))\n    lon2 = np.rad2deg(np.arctan2(x2[1], x2[0]))\n    return [(float(lat1), float(lon1)), (float(lat2), float(lon2))]\n\nintersect_pts = intersection_of_gc(\"boulder\", \"boston\", \"greenwich\", \"cairo\")\nprint(f\"Intersection points for Great Circle Arc A (Boulder to Boston) an B (Greenwich to Cairo) = {intersect_pts}\")\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#math-of-intersection","position":13},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl3":"Plot Intersections with Great Circle Paths","lvl2":"Find the intersection of two great circle paths"},"type":"lvl3","url":"/notebooks/tutorials/path-intersection#plot-intersections-with-great-circle-paths","position":14},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl3":"Plot Intersections with Great Circle Paths","lvl2":"Find the intersection of two great circle paths"},"content":"The intersection points will be easier to understand when plotted on a map, so let’s plot the two great circle paths and highlight where they intersect.\n\n# See Previous Notebooks to see how we generated a list of points to represent the great circle path\n\ndef generate_latitude_along_gc(start_point=None, end_point=None, number_of_lon_pts=360):\n    lon1 = np.deg2rad(location_df.loc[start_point, \"longitude\"])\n    lat1 = np.deg2rad(location_df.loc[start_point, \"latitude\"])\n    lon2 = np.deg2rad(location_df.loc[end_point, \"longitude\"])\n    lat2 = np.deg2rad(location_df.loc[end_point, \"latitude\"])\n\n    # Verify not meridian (longitude passes through the poles)\n    if np.sin(lon1 - lon2) == 0:\n        print(\"Invalid inputs: start/end points are meridians\")\n        # plotting meridians at 0 longitude through all latitudes\n        meridian_lat = np.arange(-90, 90, 180/len(longitude_lst)) # split in n number\n        meridians = []\n        for lat in meridian_lat:\n            meridians.append((lat, 0))\n        return meridians\n\n    # verify not anitpodal (diametrically opposite, points)\n    if lat1 + lat2 == 0 and abs(lon1-lon2) == np.pi:\n        print(\"Invalid inputs: start/end points are antipodal\")\n        return []\n\n    # note: can be expanded to handle input of np arrays by filter out antipodal/merdiain points\n\n    # generate n total number of longitude points along the great circle\n    # https://github.com/rspatial/geosphere/blob/master/R/greatCircle.R#L18C3-L18C7\n    gc_lon_lst = []\n    for lon in range(1, number_of_lon_pts+1):\n        new_lon = (lon  * (360/number_of_lon_pts) - 180)\n        gc_lon_lst.append(np.deg2rad(new_lon))\n\n    # Intermediate points on a great circle: https://edwilliams.org/avform147.htm\"\n    gc_lat_lon = []\n    for gc_lon in gc_lon_lst:\n        num = np.sin(lat1)*np.cos(lat2)*np.sin(gc_lon-lon2)-np.sin(lat2)*np.cos(lat1)*np.sin(gc_lon-lon1)\n        den = np.cos(lat1)*np.cos(lat2)*np.sin(lon1-lon2)\n        new_lat = np.arctan(num/den)\n        gc_lat_lon.append((np.rad2deg(new_lat), np.rad2deg(gc_lon)))\n    return gc_lat_lon\n\ndef interpolate_points_along_gc(start_point=None, end_point=None,\n                                distance_between_points_meter=0): \n    geodesic = Geod(ellps=\"WGS84\")\n    \n    lat_start = location_df.loc[start_point, \"latitude\"]\n    lon_start = location_df.loc[start_point, \"longitude\"]\n    lat_end = location_df.loc[end_point, \"latitude\"]\n    lon_end = location_df.loc[end_point, \"longitude\"]\n\n    lat_lon_points = [(lat_start, lon_start)]\n    \n    # move to next point when distance between points is less than the equal distance\n    move_to_next_point = True\n    while(move_to_next_point):\n        forward_bearing, _, distance_meters = geodesic.inv(lon_start,\n                                                            lat_start, \n                                                            lon_end,\n                                                            lat_end)\n        if distance_meters < distance_between_points_meter:\n            # ends before overshooting\n            move_to_next_point = False\n        else:\n            start_point = geopy.Point(lat_start, lon_start)\n            distance_to_move = geopy.distance.distance(\n                            kilometers=distance_between_points_meter /\n                            1000)  # distance to move towards the next point\n            final_position = distance_to_move.destination(\n                            start_point, bearing=forward_bearing)\n            lat_lon_points.append((final_position.latitude, final_position.longitude))\n            # new starting position is newly found end position\n            lon_start, lat_start = final_position.longitude, final_position.latitude\n    lat_lon_points.append((lat_end, lon_end))\n    return lat_lon_points\n\ndef arc_points(start_point=None, end_point=None,\n               n_total_points=10):\n    start_lat = location_df.loc[start_point, \"latitude\"]\n    start_lon = location_df.loc[start_point, \"longitude\"]\n    end_lat = location_df.loc[end_point, \"latitude\"]\n    end_lon = location_df.loc[end_point, \"longitude\"]\n\n    geodesic = Geod(ellps=\"WGS84\")\n\n    _, _, distance_meter =  geodesic.inv(start_lon,\n                                        start_lat,\n                                        end_lon,\n                                        end_lat)\n        \n    distance_between_points_meter = distance_meter / (n_total_points + 1)\n\n    \n    points_along_arc = interpolate_points_along_gc(start_point, end_point,\n                                              distance_between_points_meter)\n    return points_along_arc\n\ndef plot_gc_with_intersection(start_gc1=None, end_gc1=None,\n                             start_gc2=None, end_gc2=None,\n                             lon_west=-180, lon_east=180,\n                             lat_south=-90, lat_north=90):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n\n    # Plot Great Circle Path for Path A and B\n    gc_one_lat_pts = generate_latitude_along_gc(start_gc1, end_gc1)\n    longitudes = [x[1] for x in gc_one_lat_pts] # longitude\n    latitudes = [x[0] for x in gc_one_lat_pts] # latitude\n    plt.plot(longitudes, latitudes, c=\"cornflowerblue\", label=\"GC Path A\")\n    gc_two_lat_pts = generate_latitude_along_gc(start_gc2, end_gc2)\n    longitudes = [x[1] for x in gc_two_lat_pts] # longitude\n    latitudes = [x[0] for x in gc_two_lat_pts] # latitude\n    plt.plot(longitudes, latitudes, c=\"orange\", label=\"GC Path B\")\n\n    # Plot intersection points between two paths in purple\n    intersection_point = intersection_of_gc(start_gc1, end_gc1,\n                                            start_gc2, end_gc2)\n    longitudes = [x[1] for x in intersection_point] # longitude\n    latitudes = [x[0] for x in intersection_point] # latitude\n    plt.scatter(longitudes, latitudes, s=200, c=\"purple\", label=\"intersection\")\n\n    # Plot Great Circle Arc 1 in red\n    gc_one_arc_pts = arc_points(start_gc1, end_gc1)\n    longitudes = [x[1] for x in gc_one_arc_pts] # longitude\n    latitudes = [x[0] for x in gc_one_arc_pts] # latitude\n    plt.plot(longitudes, latitudes, c=\"red\", label=\"GC Arc A\")\n\n    # Plot Great Circle Arc 2 in light blue-green (cyan)\n    gc_two_arc_pts = arc_points(start_gc2, end_gc2)\n    longitudes = [x[1] for x in gc_two_arc_pts] # longitude\n    latitudes = [x[0] for x in gc_two_arc_pts] # latitude\n    plt.plot(longitudes, latitudes, c=\"cyan\", label=\"GC Arc B\")\n\n    plt.legend(loc=\"lower left\")\n    plt.title(f\"Intersection Point = {intersection_point}\")\n    plt.show()\n\nplot_gc_with_intersection(\"boulder\", \"boston\", \"greenwich\", \"cairo\")\n\nplot_gc_with_intersection(\"arecibo\", \"zambezi\", \"johannesburg\", \"reykjavík\")\n\n\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#plot-intersections-with-great-circle-paths","position":15},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#summary","position":16},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Summary"},"content":"In this notebook, we determined the position where two great circle paths interact on the globe.","type":"content","url":"/notebooks/tutorials/path-intersection#summary","position":17},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/tutorials/path-intersection#whats-next","position":18},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl3":"What’s next?","lvl2":"Summary"},"content":"Next, we will calculate the internal angles associated with multiple great circles.\n\n","type":"content","url":"/notebooks/tutorials/path-intersection#whats-next","position":19},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/tutorials/path-intersection#resources-and-references","position":20},{"hierarchy":{"lvl1":"Intersections of Great Circles","lvl2":"Resources and references"},"content":"\n\nAviation Formulary V1.47\n\nMoveable Type Script","type":"content","url":"/notebooks/tutorials/path-intersection#resources-and-references","position":21},{"hierarchy":{"lvl1":"Angles and Great Circles"},"type":"lvl1","url":"/notebooks/tutorials/angles","position":0},{"hierarchy":{"lvl1":"Angles and Great Circles"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/angles","position":1},{"hierarchy":{"lvl1":"Angles and Great Circles"},"type":"lvl1","url":"/notebooks/tutorials/angles#angles-and-great-circles","position":2},{"hierarchy":{"lvl1":"Angles and Great Circles"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/angles#angles-and-great-circles","position":3},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/angles#overview","position":4},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Overview"},"content":"Multiple great circle paths will always intersection at some point along the globe, and at these points, they form internal angles.\n\nDetermine the acute and obtuse angle formed by two great circle paths\n\nDetermine the directed angle formed by two great circle paths based on an intersection point\n\n","type":"content","url":"/notebooks/tutorials/angles#overview","position":5},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/angles#prerequisites","position":6},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 20 minutes\n\n\n\n","type":"content","url":"/notebooks/tutorials/angles#prerequisites","position":7},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/angles#imports","position":8},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Imports"},"content":"Import Packages\n\nSetup location dataframe with coordinates\n\nimport pandas as pd       # reading in data for location information from text file\nimport numpy as np        # working with arrays, vectors, cross/dot products, and radians\n\nfrom pyproj import Geod   # working with the Earth as an ellipsod (WGS-84)\nimport geopy.distance     # working with the Earth as an ellipsod\n\nimport matplotlib.pyplot as plt                        # plotting a graph\nfrom cartopy import crs as ccrs, feature as cfeature   # plotting a world map\n\n# Get all Coordinates for Locations\nlocation_df = pd.read_csv(\"../location_full_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df.head()\n\nlocation_df.index = location_df[\"name\"]\n\n","type":"content","url":"/notebooks/tutorials/angles#imports","position":9},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Determine the acute and obtuse angle formed by two great circle paths"},"type":"lvl2","url":"/notebooks/tutorials/angles#determine-the-acute-and-obtuse-angle-formed-by-two-great-circle-paths","position":10},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Determine the acute and obtuse angle formed by two great circle paths"},"content":"At an intersection point, two great circle paths will form both an acute and obtuse angle.\n\ndef angle_between_arcs(start_gc1=None, end_gc1=None,\n                       start_gc2=None, end_gc2=None):\n    # get normal of planes containing great circles\n    normal_one = np.cross([location_df.loc[start_gc1, \"cart_x\"],\n                           location_df.loc[start_gc1, \"cart_y\"],\n                           location_df.loc[start_gc1, \"cart_z\"]],\n                          [location_df.loc[end_gc1, \"cart_x\"],\n                           location_df.loc[end_gc1, \"cart_y\"],\n                           location_df.loc[end_gc1,\"cart_z\"]])\n    normal_two = np.cross([location_df.loc[start_gc2, \"cart_x\"],\n                           location_df.loc[start_gc2, \"cart_y\"],\n                           location_df.loc[start_gc2, \"cart_z\"]],\n                          [location_df.loc[end_gc2, \"cart_x\"],\n                           location_df.loc[end_gc2, \"cart_y\"],\n                           location_df.loc[end_gc2,\"cart_z\"]])\n\n    # dot product to obtain the angle between the normal planes\n    angle_between_planes = np.dot(normal_one, normal_two)\n\n    # divide by the magnitude of the vectors, inverse of cos to find angle\n    angle = np.arccos(np.dot(normal_one, normal_two) / \n                    (np.linalg.norm(normal_one) * np.linalg.norm(normal_two)))\n    obtuse_acute_angle = (float(np.rad2deg(angle)), float(((360-(2*np.rad2deg(angle)))/2)))\n    obtuse_angle = np.max(obtuse_acute_angle)\n\n    print(f\"Acute Angle  = {np.min(obtuse_acute_angle)} degrees\")\n    print(f\"Obtuse Angle = {np.max(obtuse_acute_angle)} degrees\")\n    return obtuse_acute_angle\n\nangle_between_arcs(\"boulder\", \"boston\", \"johannesburg\", \"reykjavík\")\n\n","type":"content","url":"/notebooks/tutorials/angles#determine-the-acute-and-obtuse-angle-formed-by-two-great-circle-paths","position":11},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Determine the directed angle formed by two great circle paths based on an intersection point"},"type":"lvl2","url":"/notebooks/tutorials/angles#determine-the-directed-angle-formed-by-two-great-circle-paths-based-on-an-intersection-point","position":12},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Determine the directed angle formed by two great circle paths based on an intersection point"},"content":"","type":"content","url":"/notebooks/tutorials/angles#determine-the-directed-angle-formed-by-two-great-circle-paths-based-on-an-intersection-point","position":13},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Overview of Directed Angles","lvl2":"Determine the directed angle formed by two great circle paths based on an intersection point"},"type":"lvl3","url":"/notebooks/tutorials/angles#overview-of-directed-angles","position":14},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Overview of Directed Angles","lvl2":"Determine the directed angle formed by two great circle paths based on an intersection point"},"content":"Most angles are undirected angles, where the configuration of the sides that form the angle are not important. A directed angle is useful when the configuration and ordering of the sides is important.\n\nFor example, three points A, B, and C, define the sides of an angle (A->B and A->C) where A is the intersection point of the two arcs AB and AC. An undirected angle will return an unsigned value. However, a directed angle returns a signed angle, where it is:\n\nPositive if C is to the left of the great circle arc AB\n\nNegative if C is to the right of the great circle arc AB\n\nSo, a directed positive angle is counterclockwise, while a negative angle is clockwise.\n\nSee More: Directed Angles\n\ndef directed_angle(b_coords=None, c_coords=None, a_coords=None):\n    # determine cartesian_coordinates from intersect points\n    earth_radius = 6378137  # meters\n    latitude = np.deg2rad(a_coords[0])\n    longitude = np.deg2rad(a_coords[1])\n    cart_x = earth_radius * np.cos(latitude) * np.cos(longitude)\n    cart_y = earth_radius * np.cos(latitude) * np.sin(longitude)\n    cart_z = earth_radius * np.sin(latitude)\n\n    # get normal of planes containing great circles\n    normal_one = np.cross([cart_x,\n                           cart_y,\n                           cart_z],\n                          [location_df.loc[b_coords, \"cart_x\"],\n                           location_df.loc[b_coords, \"cart_y\"],\n                           location_df.loc[b_coords, \"cart_z\"]])\n    normal_two = np.cross([cart_x,\n                           cart_y,\n                           cart_z],\n                          [location_df.loc[c_coords, \"cart_x\"],\n                           location_df.loc[c_coords, \"cart_y\"],\n                           location_df.loc[c_coords, \"cart_z\"]])\n    # dot product to obtain the angle between the normal planes\n    angle_between_planes = np.dot(normal_one, normal_two)\n    # divide by the magnitude of the vectors, inverse of cos to find angle\n    angle = np.arccos(np.dot(normal_one, normal_two) / \n                    (np.linalg.norm(normal_one) * np.linalg.norm(normal_two)))\n    angle = np.rad2deg(angle)\n\n    # take the cross product of two vectors A->B and A->C\n    v_ab = np.array([[cart_x,\n                    cart_y,\n                    cart_z],\n                    [location_df.loc[b_coords, \"cart_x\"],\n                     location_df.loc[b_coords, \"cart_y\"],\n                     location_df.loc[b_coords, \"cart_z\"]]])\n    v_ac = np.array([[cart_x,\n                    cart_y,\n                    cart_z],\n                    [location_df.loc[c_coords, \"cart_x\"],\n                     location_df.loc[c_coords, \"cart_y\"],\n                     location_df.loc[c_coords, \"cart_z\"]]])\n\n    cross_prod = np.cross(v_ab, v_ac)\n\n    # inverse of the sign of the cross product\n    sign_angle = -1*np.sign(cross_prod[1][-1]) * angle\n    return float(sign_angle)\n\n","type":"content","url":"/notebooks/tutorials/angles#overview-of-directed-angles","position":15},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Calculate Intersection Point Between Two Great Circle Paths","lvl2":"Determine the directed angle formed by two great circle paths based on an intersection point"},"type":"lvl3","url":"/notebooks/tutorials/angles#calculate-intersection-point-between-two-great-circle-paths","position":16},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Calculate Intersection Point Between Two Great Circle Paths","lvl2":"Determine the directed angle formed by two great circle paths based on an intersection point"},"content":"\n\n# See previous notebook to see how this function is defined\n\ndef intersection_of_gc(start_gc1=None, end_gc1=None,\n                      start_gc2=None, end_gc2=None):\n    # get normal of planes containing great circles\n\n    # cross product of vectors\n    normal_one = np.cross([location_df.loc[start_gc1, \"cart_x\"],\n                           location_df.loc[start_gc1, \"cart_y\"],\n                           location_df.loc[start_gc1, \"cart_z\"]],\n                          [location_df.loc[end_gc1, \"cart_x\"],\n                           location_df.loc[end_gc1, \"cart_y\"],\n                           location_df.loc[end_gc1, \"cart_z\"]])\n    normal_two = np.cross([location_df.loc[start_gc2, \"cart_x\"],\n                           location_df.loc[start_gc2, \"cart_y\"],\n                           location_df.loc[start_gc2, \"cart_z\"]],\n                          [location_df.loc[end_gc2, \"cart_x\"],\n                           location_df.loc[end_gc2, \"cart_y\"],\n                           location_df.loc[end_gc2, \"cart_z\"]])\n\n    # intersection of planes, normal to the poles of each plane\n    line_of_intersection = np.cross(normal_one, normal_two)\n\n    # intersection points (one on each side of the earth)\n    x1 = line_of_intersection /  np.sqrt(line_of_intersection[0]**2 + line_of_intersection[1]**2 + line_of_intersection[2]**2) \n    x2 = -x1\n    lat1 = np.rad2deg(np.arctan2(x1[2], np.sqrt(pow(x1[0],2)+pow(x1[1],2))))\n    lon1 = np.rad2deg(np.arctan2(x1[1], x1[0]))\n    lat2 = np.rad2deg(np.arctan2(x2[2], np.sqrt(pow(x2[0],2)+pow(x2[1],2))))\n    lon2 = np.rad2deg(np.arctan2(x2[1], x2[0]))\n    return [(float(lat1), float(lon1)), (float(lat2), float(lon2))]\n\nintersect_pts = intersection_of_gc(\"boulder\", \"boston\", \"johannesburg\", \"reykjavík\")\nprint(f\"Intersection points between great circle arc 1 (Boulder -> Boston) and 2 (Johannesburg -> Reykjavík): \\n{intersect_pts}\")\n\n# Arcs defined as A->B and A->C where A is the intersection\ndirected_angle(a_coords=intersect_pts[0],\n               b_coords=\"boulder\",\n               c_coords=\"reykjavík\")\n\n# Arcs defined as A->B and A->C where A is the intersection\ndirected_angle(a_coords=intersect_pts[-1],\n               b_coords=\"boulder\",\n               c_coords=\"reykjavík\")\n\n","type":"content","url":"/notebooks/tutorials/angles#calculate-intersection-point-between-two-great-circle-paths","position":17},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Plot Directed Angle","lvl2":"Determine the directed angle formed by two great circle paths based on an intersection point"},"type":"lvl3","url":"/notebooks/tutorials/angles#plot-directed-angle","position":18},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"Plot Directed Angle","lvl2":"Determine the directed angle formed by two great circle paths based on an intersection point"},"content":"A negative directed angle is clockwise, while a positive directed angle is counterclockwise. This can be easier to understand when plotted.\n\n# See previous section for more information\n\n# Generate Latitude Coordinates based on Longitude Coordinates\ndef generate_latitude_along_gc(start_lat=None, start_lon=None,\n                               end_lat=None, end_lon=None,\n                               number_of_lon_pts=360):\n    lon1 = np.deg2rad(start_lon)\n    lat1 = np.deg2rad(start_lat)\n    lon2 = np.deg2rad(end_lon)\n    lat2 = np.deg2rad(end_lat)\n\n    # Verify not meridian (longitude passes through the poles)\n    if np.sin(lon1 - lon2) == 0:\n        print(\"Invalid inputs: start/end points are meridians\")\n        # plotting meridians at 0 longitude through all latitudes\n        meridian_lat = np.arange(-90, 90, 180/len(longitude_lst)) # split in n number\n        meridians = []\n        for lat in meridian_lat:\n            meridians.append((lat, 0))\n        return meridians\n\n    # verify not anitpodal (diametrically opposite, points)\n    if lat1 + lat2 == 0 and abs(lon1-lon2) == np.pi:\n        print(\"Invalid inputs: start/end points are antipodal\")\n        return []\n\n    # note: can be expanded to handle input of np arrays by filter out antipodal/merdiain points\n\n    # generate n total number of longitude points along the great circle\n    # https://github.com/rspatial/geosphere/blob/master/R/greatCircle.R#L18C3-L18C7\n    gc_lon_lst = []\n    for lon in range(1, number_of_lon_pts+1):\n        new_lon = (lon  * (360/number_of_lon_pts) - 180)\n        gc_lon_lst.append(np.deg2rad(new_lon))\n\n    # Intermediate points on a great circle: https://edwilliams.org/avform147.htm\"\n    gc_lat_lon = []\n    for gc_lon in gc_lon_lst:\n        num = np.sin(lat1)*np.cos(lat2)*np.sin(gc_lon-lon2)-np.sin(lat2)*np.cos(lat1)*np.sin(gc_lon-lon1)\n        den = np.cos(lat1)*np.cos(lat2)*np.sin(lon1-lon2)\n        new_lat = np.arctan(num/den)\n        gc_lat_lon.append((np.rad2deg(new_lat), np.rad2deg(gc_lon)))\n    return gc_lat_lon\n\ndef interpolate_points_along_gc(lat_start=None, lon_start=None,\n                                lat_end=None, lon_end=None,\n                                distance_between_points_meter=0): \n    geodesic = Geod(ellps=\"WGS84\")\n    \n    lat_lon_points = [(lat_start, lon_start)]\n    \n    # move to next point when distance between points is less than the equal distance\n    move_to_next_point = True\n    while(move_to_next_point):\n        forward_bearing, _, distance_meters = geodesic.inv(lon_start,\n                                                            lat_start, \n                                                            lon_end,\n                                                            lat_end)\n        if distance_meters < distance_between_points_meter:\n            # ends before overshooting\n            move_to_next_point = False\n        else:\n            start_point = geopy.Point(lat_start, lon_start)\n            distance_to_move = geopy.distance.distance(\n                            kilometers=distance_between_points_meter /\n                            1000)  # distance to move towards the next point\n            final_position = distance_to_move.destination(\n                            start_point, bearing=forward_bearing)\n            lat_lon_points.append((final_position.latitude, final_position.longitude))\n            # new starting position is newly found end position\n            lon_start, lat_start = final_position.longitude, final_position.latitude\n    lat_lon_points.append((lat_end, lon_end))\n    return lat_lon_points\n\ndef arc_points(start_lat=None, start_lon=None,\n               end_lat=None, end_lon=None,\n               n_total_points=10):\n\n    geodesic = Geod(ellps=\"WGS84\")\n\n    _, _, distance_meter =  geodesic.inv(start_lon,\n                                        start_lat,\n                                        end_lon,\n                                        end_lat)\n        \n    distance_between_points_meter = distance_meter / (n_total_points + 1)\n\n    \n    points_along_arc = interpolate_points_along_gc(start_lat, start_lon,\n                                                   end_lat, end_lon,\n                                                    distance_between_points_meter)\n    return points_along_arc\n\ndef plot_gc_directed_angle(a_coords=None, b_coords=None,c_coords=None,\n                           angle=None,\n                           lon_west=-180, lon_east=180,\n                           lat_south=-90, lat_north=90):\n    # A = intersect point\n    # A->B and A->C where C is the angle to determine sign\n\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n\n    # Plot Great Circle Path\n    gc_one_lat_pts = generate_latitude_along_gc(start_lat=a_coords[0],\n                                                start_lon=a_coords[1],\n                                                end_lat=location_df.loc[b_coords, \"latitude\"],\n                                                end_lon=location_df.loc[b_coords, \"longitude\"])\n    longitudes = [x[1] for x in gc_one_lat_pts] # longitude\n    latitudes = [x[0] for x in gc_one_lat_pts] # latitude\n    plt.plot(longitudes, latitudes)\n    gc_two_lat_pts =  generate_latitude_along_gc(start_lat=a_coords[0],\n                                                start_lon=a_coords[1],\n                                                end_lat=location_df.loc[c_coords, \"latitude\"],\n                                                end_lon=location_df.loc[c_coords, \"longitude\"])\n    longitudes = [x[1] for x in gc_two_lat_pts] # longitude\n    latitudes = [x[0] for x in gc_two_lat_pts] # latitude\n    plt.plot(longitudes, latitudes)\n\n    # Plot Great Circle Arc\n    gc_one_arc_pts = arc_points(start_lat=a_coords[0],\n                               start_lon=a_coords[1],\n                               end_lat=location_df.loc[b_coords, \"latitude\"],\n                               end_lon=location_df.loc[b_coords, \"longitude\"])\n    longitudes = [x[1] for x in gc_one_arc_pts] # longitude\n    latitudes = [x[0] for x in gc_one_arc_pts] # latitude\n    plt.plot(longitudes, latitudes, c=\"pink\")\n    gc_two_arc_pts = arc_points(start_lat=a_coords[0],\n                               start_lon=a_coords[1],\n                               end_lat=location_df.loc[c_coords, \"latitude\"],\n                               end_lon=location_df.loc[c_coords, \"longitude\"])\n    longitudes = [x[1] for x in gc_two_arc_pts] # longitude\n    latitudes = [x[0] for x in gc_two_arc_pts] # latitude\n    plt.plot(longitudes, latitudes, c=\"green\")\n\n    # plot A, B, C points in different colors\n    fz = 30\n    offset = 3\n    plt.scatter(a_coords[1], a_coords[0], s=100, c=\"red\", label=\"A\")\n    ax.annotate(\"A\", (a_coords[1]+offset, a_coords[0]+offset), fontsize=fz)\n    plt.scatter(location_df.loc[b_coords, \"longitude\"],\n               location_df.loc[b_coords, \"latitude\"],\n                s=100, c=\"blue\", label=\"B\")\n    ax.annotate(\"B\", (location_df.loc[b_coords, \"longitude\"]-(4*offset),\n                      location_df.loc[b_coords, \"latitude\"]-offset),\n                        fontsize=fz)\n    plt.scatter(location_df.loc[c_coords, \"longitude\"],\n                location_df.loc[c_coords, \"latitude\"], \n                s=100, c=\"cyan\", label=\"C\")\n    ax.annotate(\"C\", (location_df.loc[c_coords, \"longitude\"]+offset,\n                      location_df.loc[c_coords, \"latitude\"]+offset),\n                        fontsize=fz)\n    ax.quiver(location_df.loc[b_coords, \"longitude\"],\n              location_df.loc[b_coords, \"latitude\"], \n              (location_df.loc[c_coords, \"longitude\"]-location_df.loc[b_coords, \"longitude\"]), \n              (location_df.loc[c_coords, \"latitude\"]-location_df.loc[b_coords, \"latitude\"]), \n              angles='xy', scale_units='xy', scale=1)    \n    \n    if angle > 0: \n        sign = \"Counterclockwise\"\n    if angle < 0: \n        sign = \"Clockwise\"\n    if angle == 0:\n        sign = \"Colinear\"\n    plt.title(f\"Direction = {sign}, {angle}\")\n    plt.legend()\n    plt.show()\n\n# Arcs defined as A->B and A->C where A is the intersection\nintersect_pts = intersection_of_gc(\"boulder\", \"boston\", \"reykjavík\", \"johannesburg\")\n\ndirect_angle = directed_angle(a_coords=intersect_pts[0],\n                              b_coords=\"boulder\",\n                              c_coords=\"reykjavík\")\n\nplot_gc_directed_angle(a_coords=intersect_pts[0],\n                       b_coords=\"boulder\",\n                       c_coords=\"reykjavík\",\n                       angle=direct_angle)\n\n# Arcs defined as A->B and A->C where A is the intersection\nintersect_pts = intersection_of_gc(\"boulder\", \"boston\", \"reykjavík\", \"johannesburg\")\n\ndirect_angle = directed_angle(a_coords=intersect_pts[-1],\n                              b_coords=\"boulder\",\n                              c_coords=\"reykjavík\")\n\nplot_gc_directed_angle(a_coords=intersect_pts[-1],\n                       b_coords=\"boulder\",\n                       c_coords=\"reykjavík\",\n                       angle=direct_angle)\n\n# Arcs defined as A->B and A->C where A is the intersection\nintersect_pts = intersection_of_gc(\"zambezi\", \"boston\", \"greenwich\", \"johannesburg\")\n\ndirect_angle = directed_angle(a_coords=intersect_pts[0],\n                              b_coords=\"zambezi\",\n                              c_coords=\"greenwich\")\n\nplot_gc_directed_angle(a_coords=intersect_pts[0],\n                       b_coords=\"zambezi\",\n                       c_coords=\"reykjavík\",\n                       angle=direct_angle)\n\n# Arcs defined as A->B and A->C where A is the intersection\nintersect_pts = intersection_of_gc(\"zambezi\", \"boston\", \"greenwich\", \"johannesburg\")\n\ndirect_angle = directed_angle(a_coords=intersect_pts[-1],\n                              b_coords=\"zambezi\",\n                              c_coords=\"greenwich\")\n\nplot_gc_directed_angle(a_coords=intersect_pts[-1],\n                       b_coords=\"zambezi\",\n                       c_coords=\"reykjavík\",\n                       angle=direct_angle)\n\n\n\n","type":"content","url":"/notebooks/tutorials/angles#plot-directed-angle","position":19},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/tutorials/angles#summary","position":20},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Summary"},"content":"In this notebook, we determined how to find the angles and directed angle formed by the intersection of two great circle paths.","type":"content","url":"/notebooks/tutorials/angles#summary","position":21},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"What’s next?","lvl2":"Summary"},"type":"lvl3","url":"/notebooks/tutorials/angles#whats-next","position":22},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl3":"What’s next?","lvl2":"Summary"},"content":"Up next, we will cover how to calculate spherical polygons and the area of spherical polygons.\n\n","type":"content","url":"/notebooks/tutorials/angles#whats-next","position":23},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/tutorials/angles#resources-and-references","position":24},{"hierarchy":{"lvl1":"Angles and Great Circles","lvl2":"Resources and references"},"content":"\n\nAviation Formulary V1.47\n\nMoveable Type Script","type":"content","url":"/notebooks/tutorials/angles#resources-and-references","position":25},{"hierarchy":{"lvl1":"Spherical Polygons and Areas"},"type":"lvl1","url":"/notebooks/tutorials/polygon-area","position":0},{"hierarchy":{"lvl1":"Spherical Polygons and Areas"},"content":"\n\n","type":"content","url":"/notebooks/tutorials/polygon-area","position":1},{"hierarchy":{"lvl1":"Spherical Polygons and Areas"},"type":"lvl1","url":"/notebooks/tutorials/polygon-area#spherical-polygons-and-areas","position":2},{"hierarchy":{"lvl1":"Spherical Polygons and Areas"},"content":"\n\n\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#spherical-polygons-and-areas","position":3},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#overview","position":4},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Overview"},"content":"In this notebook, we will calculate how to use spherical polygons on a unit sphere to determine areas and perimeters.\n\nCalculate area and permieter of quadrilateral patch on a unit sphere\n\nDetermine if a given point is within a spherical polygon\n\nMean center of spherical polygon\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#overview","position":5},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#prerequisites","position":6},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nNumpy\n\nNecessary\n\nUsed to work with large arrays\n\nPandas\n\nNecessary\n\nUsed to read in and organize data (in particular dataframes)\n\nIntro to Cartopy\n\nHelpful\n\nWill be used for adding maps to plotting\n\nMatplotlib\n\nHelpful\n\nWill be used for plotting\n\nTime to learn: 20 minutes\n\n\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#prerequisites","position":7},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#imports","position":8},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Imports"},"content":"Import Packages\n\nSetup location dataframe with coordinates\n\nimport pandas as pd       # reading in data for location information from text file\nimport numpy as np        # working with arrays, vectors, cross/dot products, and radians\n\nfrom pyproj import Geod   # working with the Earth as an ellipsod (WGS-84)\n\nfrom shapely.geometry import Point\nfrom shapely.geometry.polygon import Polygon\n\nimport matplotlib.pyplot as plt                        # plotting a graph\nfrom cartopy import crs as ccrs, feature as cfeature   # plotting a world map\n\n# Get all Coordinates for Locations\nlocation_df = pd.read_csv(\"../location_full_coords.txt\")\nlocation_df = location_df.rename(columns=lambda x: x.strip()) # strip excess white space from column names and values\nlocation_df.head()\n\nlocation_df.index = location_df[\"name\"]\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#imports","position":9},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Area and Perimeter of quadrilateral patch"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#area-and-perimeter-of-quadrilateral-patch","position":10},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Area and Perimeter of quadrilateral patch"},"content":"We can make use of the pyproj Python package to calculate the area and perimeter of a patch formed by a list of latitude and longitude coordinates for an ellipsoid or a unit sphere.\n\ndef area_of_polygon_ellps(poly_pts=None):\n    geod = Geod(ellps=\"WGS84\")\n    longitudes = [location_df.loc[pt, \"longitude\"] for pt in poly_pts]\n    latitudes = [location_df.loc[pt, \"latitude\"] for pt in poly_pts]\n    poly_area_m, poly_perimeter_m = geod.polygon_area_perimeter(longitudes, latitudes)\n    return abs(poly_area_m) * 1e-6, poly_perimeter_m/1000 # km^2 and km\n\ndef area_of_polygon_unit_sphere(poly_pts=None):\n    geod = Geod(ellps=\"sphere\") # 'sphere': {'a': 6370997.0, 'b': 6370997.0, 'description': 'Normal Sphere (r=6370997)'\n    longitudes = [location_df.loc[pt, \"longitude\"] for pt in poly_pts]\n    latitudes = [location_df.loc[pt, \"latitude\"] for pt in poly_pts]\n    poly_area_m, poly_perimeter_m = geod.polygon_area_perimeter(longitudes, latitudes)\n    return abs(poly_area_m) * 1e-6, poly_perimeter_m/1000 # km^2 and km\n\nLet’s compare how area and perimeter vary based on whether you use an ellpsoid like  WGS-84 and a unit sphere. The changes will become more pronounced as you move further towards the poles.\n\narea_ellps, perimeter_ellps = area_of_polygon_ellps([\"boulder\", \"boston\",\n                                             \"arecibo\", \"houston\"])\narea_us, perimeter_us = area_of_polygon_unit_sphere([\"boulder\", \"boston\",\n                                             \"arecibo\", \"houston\"])\nprint(f\"Area Ellipsoid   = {area_ellps} km^2\")\nprint(f\"Area Unit Sphere = {area_us} km^2\")\nprint(f\"Perimeter Ellipsoid = {perimeter_ellps} km\")\nprint(f\"Perimeter Unit SPhere = {perimeter_us} km\")\nprint(f\"Roughly {(area_ellps/509600000)*100:.2f}% of the Earth's Surface\")\nprint(f\"Roughly {(area_us/509600000)*100:.2f}% of the Earth's Surface\")\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#area-and-perimeter-of-quadrilateral-patch","position":11},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl3":"Plot Area of Quadrilateral Patch","lvl2":"Area and Perimeter of quadrilateral patch"},"type":"lvl3","url":"/notebooks/tutorials/polygon-area#plot-area-of-quadrilateral-patch","position":12},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl3":"Plot Area of Quadrilateral Patch","lvl2":"Area and Perimeter of quadrilateral patch"},"content":"Let’s see what spherical polygons looks like on a world map!\n\ndef plot_area(pt_lst=None,\n                   lon_west=-180, lon_east=180,\n                   lat_south=-90, lat_north=90):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n\n   # plot points\n    longitudes = [location_df.loc[x, \"longitude\"] for x in pt_lst] # longitude\n    latitudes = [location_df.loc[y, \"latitude\"] for y in pt_lst] # latitude\n    plt.scatter(longitudes, latitudes, s=100, c=\"red\")\n    plt.fill(longitudes, latitudes, alpha=0.5)\n\n    # determine the area and perimeter\n    area_ellps, perimeter_ellps = area_of_polygon_ellps(pt_lst)\n    area_us, perimeter_us = area_of_polygon_unit_sphere(pt_lst)\n    print(f\"Ellipsoid Area   = {area_ellps} km^2\")\n    print(f\"Unit Sphere Area = {area_us} km^2\")\n    plt.title(f\"Roughly {(area_ellps/509600000)*100:.2f}% ({(area_us/509600000)*100:.2f}%) of the Earth's Surface\")\n    plt.show()\n\nplot_area([\"boulder\", \"boston\", \"greenwich\", \"cairo\", \"arecibo\", \"houston\"])\n\nplot_area([\"redwoods\", \"rockford\", \"boston\", \"houston\",], -130, -60, 20, 60)\n\nplot_area([\"redwoods\", \"boston\", \"houston\"], -130, -60, 20, 60)\n\nImportant\n\nMake sure that the points that form the polygon are in a clockwise or counterclockwise order. Otherwise, the polygon formed will have overlapping portions and the area will not be valid\n\n# For example: here is a list of unordered points\nplot_area([\"boulder\", \"boston\", \"houston\", \"boston\", \"cairo\", \"arecibo\", \"greenwich\"])\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#plot-area-of-quadrilateral-patch","position":13},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Determine if a given point is within a spherical polygon"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#determine-if-a-given-point-is-within-a-spherical-polygon","position":14},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Determine if a given point is within a spherical polygon"},"content":"Now that we have a spherical polygon, how can be determine if a new point lies within the area of the polygon? The shapely Python package makes this quite easy, let’s give it a shot!\n\ndef polygon_contains_points(pt_lst=None, polygon_pts=None):\n    longitudes = [location_df.loc[pt, \"longitude\"] for pt in polygon_pts]\n    latitudes = [location_df.loc[pt, \"latitude\"] for pt in polygon_pts]\n    lat_lon_coords = tuple(zip(longitudes, latitudes))\n    # setup polygon\n    polygon = Polygon(lat_lon_coords)\n    # check if new point lies within the polygon\n    contains = np.vectorize(lambda pt: polygon.contains(Point((location_df.loc[pt, \"longitude\"],\n                                                               location_df.loc[pt, \"latitude\"]))))\n    contained_by_polygon = contains(np.array(pt_lst))\n    return contained_by_polygon\n\npolygon_contains_points([\"boulder\"], [\"redwoods\", \"boston\", \"houston\"])\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#determine-if-a-given-point-is-within-a-spherical-polygon","position":15},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl3":"Plot and See if New Point within Polygon","lvl2":"Determine if a given point is within a spherical polygon"},"type":"lvl3","url":"/notebooks/tutorials/polygon-area#plot-and-see-if-new-point-within-polygon","position":16},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl3":"Plot and See if New Point within Polygon","lvl2":"Determine if a given point is within a spherical polygon"},"content":"On a map, it can be fairly intuitive to see if a point lies within a polygon or not. Let’s give it a shot!\n\ndef plot_polygon_pts(pt_lst=None, polygon_pts=None,\n                   lon_west=-180, lon_east=180,\n                   lat_south=-90, lat_north=90):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n\n    # plot polygon points\n    longitudes = [location_df.loc[x, \"longitude\"] for x in polygon_pts] # longitude\n    latitudes = [location_df.loc[y, \"latitude\"] for y in polygon_pts] # latitude\n    plt.scatter(longitudes, latitudes, s=50, c=\"blue\")\n    plt.fill(longitudes, latitudes, alpha=0.5)\n\n    # plot check points\n    pt_lst = np.array(pt_lst)\n    contains_pts = polygon_contains_points(pt_lst, polygon_pts)\n    longitudes = [location_df.loc[x, \"longitude\"] for x in pt_lst[contains_pts]] # longitude\n    latitudes = [location_df.loc[y, \"latitude\"] for y in pt_lst[contains_pts]] # latitude\n    plt.scatter(longitudes, latitudes, s=100, c=\"green\", label=\"Within Polygon\")\n    longitudes = [location_df.loc[x, \"longitude\"] for x in pt_lst[~contains_pts]] # longitude\n    latitudes = [location_df.loc[y, \"latitude\"] for y in pt_lst[~contains_pts]] # latitude\n    plt.scatter(longitudes, latitudes, s=100, c=\"red\", label=\"Not within Polygon\")\n\n    plt.legend(loc=\"lower left\")\n    plt.title(f\"Points contained within polygon = {pt_lst[contains_pts]}, not contained = {pt_lst[~contains_pts]}\")\n    plt.show()\n\npolygon_contains_points([\"boulder\"], [\"redwoods\", \"boston\", \"houston\"])\n\nplot_polygon_pts([\"boulder\"], [\"redwoods\", \"boston\", \"houston\"],\n               -130, -60, 20, 60)\n\npolygon_contains_points([\"cape canaveral\"], [\"redwoods\", \"boston\", \"houston\"])\n\nplot_polygon_pts([\"cape canaveral\"], [\"redwoods\", \"boston\", \"houston\"],\n               -130, -60, 20, 60)\n\nplot_polygon_pts([\"boulder\", \"cape canaveral\"], [\"redwoods\", \"boston\", \"houston\"],\n               -130, -60, 20, 60)\n\nplot_polygon_pts([\"boulder\", \"redwoods\"], [\"rockford\", \"boston\", \"cape canaveral\"],\n               -130, -60, 20, 60)\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#plot-and-see-if-new-point-within-polygon","position":17},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Mean center of spherical polygon"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#mean-center-of-spherical-polygon","position":18},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Mean center of spherical polygon"},"content":"A spherical polygon can have a fairly regular shape, especially as more points are added. But it is fairly simple using the shapley Python package to determine the mean center.\n\ndef polygon_centroid(polygon_pts=None):\n    longitudes = [location_df.loc[x, \"longitude\"] for x in polygon_pts]\n    latitudes = [location_df.loc[y, \"latitude\"] for y in polygon_pts]\n    lat_lon_coords = tuple(zip(longitudes, latitudes))\n    polygon = Polygon(lat_lon_coords)\n    return (polygon.centroid.y, polygon.centroid.x)\n\npolygon_centroid([\"boulder\", \"boston\", \"houston\"])\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#mean-center-of-spherical-polygon","position":19},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl3":"Plot Centroid","lvl2":"Mean center of spherical polygon"},"type":"lvl3","url":"/notebooks/tutorials/polygon-area#plot-centroid","position":20},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl3":"Plot Centroid","lvl2":"Mean center of spherical polygon"},"content":"The center of a polygon can be fairly apparently on a map, let’s give it a look!\n\ndef plot_centroid(polygon_pts=None,\n                   lon_west=-180, lon_east=180,\n                   lat_south=-90, lat_north=90):\n    # Set up world map plot\n    fig = plt.subplots(figsize=(15, 10))\n    projection_map = ccrs.PlateCarree()\n    ax = plt.axes(projection=projection_map)\n    ax.set_extent([lon_west, lon_east, lat_south, lat_north], crs=projection_map)\n    ax.coastlines(color=\"black\")\n    ax.add_feature(cfeature.STATES, edgecolor=\"black\")\n\n   # plot polygon points\n    longitudes = [location_df.loc[x, \"longitude\"] for x in polygon_pts] # longitude\n    latitudes = [location_df.loc[y, \"latitude\"] for y in polygon_pts] # latitude\n    plt.scatter(longitudes, latitudes, s=50, c=\"blue\")\n    plt.fill(longitudes, latitudes, alpha=0.5)\n\n    # plot check point\n    centeroid = polygon_centroid(polygon_pts)\n    plt.scatter(centeroid[1], centeroid[0], s=100, c=\"red\")\n    plt.title(f\"Centroid = {centeroid}\")\n    plt.show()\n\nplot_centroid([\"boulder\", \"boston\", \"houston\"],\n               -130, -60, 20, 60)\n\nplot_centroid([\"redwoods\", \"boulder\", \"cape canaveral\", \"houston\"],\n               -130, -60, 20, 60)\n\n\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#plot-centroid","position":21},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Summary"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#summary","position":22},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Summary"},"content":"This notebook covers working with spherical polygons to determine the ordering of coordinates, center of polygons, and whether or not a point lies within a spherical polygon\n\n","type":"content","url":"/notebooks/tutorials/polygon-area#summary","position":23},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Resources and references"},"type":"lvl2","url":"/notebooks/tutorials/polygon-area#resources-and-references","position":24},{"hierarchy":{"lvl1":"Spherical Polygons and Areas","lvl2":"Resources and references"},"content":"\n\nAviation Formulary V1.47\n\nMoveable Type Script","type":"content","url":"/notebooks/tutorials/polygon-area#resources-and-references","position":25}]}